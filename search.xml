<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql server事务</title>
      <link href="/2024/03/22/sql-server%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/03/22/sql-server%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>定义一个事务的开始:begin tran</li><li>提交一个事务:commit tran</li><li>回滚事务:rollback tran</li><li>在事务内设置保存点:save tran  [name]名字</li></ul><h3 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h3><ul><li>需求:想删除id为2000,2001，不删除2002的记录,需要进行回滚<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line">save tran a</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> tno<span class="operator">=</span><span class="number">2000</span></span><br><span class="line">save tran b</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> tno<span class="operator">=</span><span class="number">2001</span></span><br><span class="line">save tran c</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> tno<span class="operator">=</span><span class="number">2002</span></span><br><span class="line"><span class="keyword">rollback</span> tran c</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql server备份还原</title>
      <link href="/2024/03/22/sql-server%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
      <url>/2024/03/22/sql-server%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="使用sql语句备份数据库"><a href="#使用sql语句备份数据库" class="headerlink" title="使用sql语句备份数据库"></a>使用sql语句备份数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACKUP DATABASE teaching <span class="comment">--表名</span></span><br><span class="line"><span class="keyword">TO</span> DISK <span class="operator">=</span><span class="string">&#x27;F:\backup\teaching.bak&#x27;</span> <span class="comment">--路径名</span></span><br><span class="line"><span class="keyword">WITH</span> FORMAT</span><br></pre></td></tr></table></figure><h3 id="使用sql语句还原数据库"><a href="#使用sql语句还原数据库" class="headerlink" title="使用sql语句还原数据库"></a>使用sql语句还原数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RESTORE DATABASE </span><br><span class="line">teaching  表名</span><br><span class="line"><span class="keyword">FROM</span> DISK<span class="operator">=</span><span class="string">&#x27;F:\backup\teaching.bak&#x27;</span> <span class="comment">--路径名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视图和索引</title>
      <link href="/2024/03/22/sql-server%E8%A7%86%E5%9B%BE%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/03/22/sql-server%E8%A7%86%E5%9B%BE%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图只能对单张表进行修改更新，不能对多表进行操作</li><li>创建视图<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_student</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> sdept<span class="operator">=</span><span class="string">&#x27;电子商务&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_student</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>创建格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       唯一索引  聚集索引  非聚集索引(默认)</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][clustered][nonclustered]</span><br><span class="line">index index_name</span><br><span class="line"><span class="keyword">on</span> &#123;table_name <span class="operator">|</span>view_name <span class="operator">|</span><span class="keyword">column</span>[...n]&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index student.index_sname</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除主键索引"><a href="#删除主键索引" class="headerlink" title="删除主键索引"></a>删除主键索引</h3><ul><li>需要先删除主键约束(constraint)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">drop</span> <span class="keyword">constraint</span> PK_test</span><br></pre></td></tr></table></figure></li></ul><h3 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h3><ul><li><p>创建别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> synonym s</span><br><span class="line"><span class="keyword">for</span> student</span><br></pre></td></tr></table></figure></li><li><p>使用别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s</span><br></pre></td></tr></table></figure></li><li><p>删除同义词，不影响</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> synonym s</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DML触发器和DDL触发器</title>
      <link href="/2024/03/21/DML%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2024/03/21/DML%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h2><ul><li>定义了两个特殊的表,一个是插入表：inserted,一个是删除表:deleted</li><li>当用户执行insert语句时,所有被添加的记录都会存储在inserted表以及触发器所在的表中</li><li>当用户执行delete语句时,从触发器所在的表中被删除的行会发送到deleted表中</li><li>而对于update语句,sql server先将要进行修改的记录行存储到deleted表中,然后再将修改后的数据行存储到inserted表以及触发器所在的表中</li></ul><hr><h3 id="DML触发器-1"><a href="#DML触发器-1" class="headerlink" title="DML触发器"></a>DML触发器</h3><ul><li><p>为教师表teacher 创建一个DML触发器,在插入和修改数据的时候,自动显示所有教师的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> print_teacher <span class="comment">--触发器名称 </span></span><br><span class="line"><span class="keyword">on</span> teacher  <span class="comment">--哪张表</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">insert</span>,<span class="keyword">update</span> <span class="comment">--在插入,更新后</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="comment">--触发内容</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>触发语句<br>insert into teacher values(‘’)<br>update teacher set name&#x3D;’信心’ where id&#x3D;’1001’;</p></li></ul><h3 id="DDL触发器-库级触发器"><a href="#DDL触发器-库级触发器" class="headerlink" title="DDL触发器 库级触发器"></a>DDL触发器 库级触发器</h3><ul><li><p>在响应数据定义语言(DDL,create、alter和drop语句)时触发</p></li><li><p>案例：创建DDL触发器,来防止数据库中任意一张表的修改或者删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> limited</span><br><span class="line"><span class="keyword">on</span> database</span><br><span class="line"><span class="keyword">for</span> drop_table,alter_table</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    print <span class="string">&#x27;触发器已经阻止您对表的删除或者修改&#x27;</span></span><br><span class="line">    <span class="comment">--rollback：事务回滚</span></span><br><span class="line">    <span class="keyword">rollback</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>触发语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> teacher</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个触发器-用于登记修改表sc的数据-将修改者的信息进行记录"><a href="#创建一个触发器-用于登记修改表sc的数据-将修改者的信息进行记录" class="headerlink" title="创建一个触发器,用于登记修改表sc的数据,将修改者的信息进行记录"></a>创建一个触发器,用于登记修改表sc的数据,将修改者的信息进行记录</h3><ul><li><p>定义一张表 存储修改者的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> changer</span><br><span class="line">(</span><br><span class="line">    ch_datetime datetime, <span class="comment">--修改时间</span></span><br><span class="line">    ch_username <span class="type">varchar</span>(<span class="number">20</span>),<span class="comment">--修改名称</span></span><br><span class="line">    ch_column <span class="type">varchar</span>(<span class="number">10</span>)<span class="comment">--修改字段</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>定义触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tr_change</span><br><span class="line"><span class="keyword">on</span> sc <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     if <span class="keyword">update</span>(score)</span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line">          <span class="comment">--getdate():获取当前的时间</span></span><br><span class="line">          <span class="comment">--SUSER_SNAME():表示获取当前登陆者的名称</span></span><br><span class="line">          <span class="keyword">insert</span> <span class="keyword">into</span> changer <span class="keyword">values</span>(getdate(),SUSER_SNAME(),<span class="string">&#x27;sc.score&#x27;</span>);</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>触发定义器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> sc <span class="keyword">set</span> score<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> sno<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="instead-of触发器-替代触发器-替代原本的操作-不执行原本的触发sql语句-执行触发器内部的定义"><a href="#instead-of触发器-替代触发器-替代原本的操作-不执行原本的触发sql语句-执行触发器内部的定义" class="headerlink" title="instead of触发器,替代触发器,替代原本的操作,不执行原本的触发sql语句,执行触发器内部的定义"></a>instead of触发器,替代触发器,替代原本的操作,不执行原本的触发sql语句,执行触发器内部的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> c_stu</span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line">instead <span class="keyword">of</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">values</span>(<span class="string">&#x27;2005&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;一级教师&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="触发语句"><a href="#触发语句" class="headerlink" title="触发语句"></a>触发语句</h3><ul><li>当我们执行下面这条插入的时候,触发器会执行触发器里面的插入数据,会对teacher表进行插入,而不会对student表进行插入<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="string">&#x27;2002&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;一级教师&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="触发器的启动和删除"><a href="#触发器的启动和删除" class="headerlink" title="触发器的启动和删除"></a>触发器的启动和删除</h3><ul><li>将sc表触发器禁止<br>alter table 表名 disable trigger 触发器名</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储过程</title>
      <link href="/2024/03/20/sql-server%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/03/20/sql-server%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="存储无参过程"><a href="#存储无参过程" class="headerlink" title="存储无参过程"></a>存储无参过程</h3><ul><li><p>创建简单的存储过程</p></li><li><p>存储过程没有返回值 不带参数的存储过程后面没有()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> proc usp_helloworld</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    print <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>执行存储规程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> usp_helloworld</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建带参数的存储过程"><a href="#创建带参数的存储过程" class="headerlink" title="创建带参数的存储过程"></a>创建带参数的存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> proc usp_student(<span class="variable">@name</span> <span class="type">varchar</span>(<span class="number">20</span>),<span class="variable">@age</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> sname<span class="operator">=</span><span class="variable">@name</span> <span class="keyword">and</span> sage<span class="operator">=</span><span class="variable">@age</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>执行存储规程<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> usp_student <span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建带有输出参数的存储过程-out-关键字"><a href="#创建带有输出参数的存储过程-out-关键字" class="headerlink" title="创建带有输出参数的存储过程 out 关键字"></a>创建带有输出参数的存储过程 out 关键字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> proc count_course(</span><br><span class="line">    <span class="variable">@cn</span> <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="variable">@recordCount</span> <span class="type">int</span> <span class="keyword">out</span> 代表输出参数</span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="keyword">where</span> cno <span class="operator">=</span> <span class="variable">@cn</span></span><br><span class="line">    <span class="keyword">select</span> <span class="variable">@recordCount</span><span class="operator">=</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> sc <span class="keyword">where</span> con<span class="operator">=</span><span class="variable">@cn</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="调用具有输出参数的存储过程"><a href="#调用具有输出参数的存储过程" class="headerlink" title="调用具有输出参数的存储过程"></a>调用具有输出参数的存储过程</h3><ul><li>需要定义变量来接受<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@num</span> <span class="type">int</span> </span><br><span class="line"><span class="keyword">exec</span> count_cource <span class="string">&#x27;1001&#x27;</span>,<span class="variable">@num</span> <span class="keyword">out</span></span><br><span class="line">print <span class="variable">@num</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建带有输入输出的参数的存储过程"><a href="#创建带有输入输出的参数的存储过程" class="headerlink" title="创建带有输入输出的参数的存储过程"></a>创建带有输入输出的参数的存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> proc usp_getStudentInfo(</span><br><span class="line">    <span class="variable">@id</span> <span class="type">varchar</span>(<span class="number">20</span>), <span class="comment">--默认输入参数</span></span><br><span class="line">    <span class="variable">@name</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">out</span>, <span class="comment">--输出参数</span></span><br><span class="line">    <span class="variable">@age</span> <span class="type">int</span> output <span class="comment">--输入输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="variable">@name</span><span class="operator">=</span>sname,<span class="variable">@age</span><span class="operator">=</span>sage <span class="keyword">from</span> student <span class="keyword">where</span> sno<span class="operator">=</span><span class="variable">@id</span> <span class="keyword">and</span> sage<span class="operator">=</span><span class="variable">@age</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="调用具有输出输入参数的存储过程"><a href="#调用具有输出输入参数的存储过程" class="headerlink" title="调用具有输出输入参数的存储过程"></a>调用具有输出输入参数的存储过程</h3><ul><li>需要定义变量来接受<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@name</span> <span class="type">varchar</span>(<span class="number">20</span>),<span class="variable">@age</span> <span class="type">int</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">exec</span> usp_getStudentInfo <span class="string">&#x27;1001&#x27;</span>,<span class="variable">@name</span> <span class="keyword">out</span>,<span class="number">20</span>,<span class="variable">@age</span> output</span><br><span class="line">print <span class="variable">@name</span> <span class="operator">+</span> <span class="string">&#x27;#&#x27;</span> <span class="operator">+</span> <span class="built_in">cast</span>(<span class="variable">@age</span> <span class="keyword">as</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="系统存储过程基本命令"><a href="#系统存储过程基本命令" class="headerlink" title="系统存储过程基本命令"></a>系统存储过程基本命令</h3><ul><li>sp_databases 查看数据库</li><li>sp_tables 查看表</li><li>sp_tables ×××  查看当前哪张表 </li><li>sp_columns ××× 查看哪张表的列</li><li>sp_helpindex ××× 查看索引(包含主键)</li><li>sp_helpconstraint ×××× 查看哪张表的约束</li><li>sp_renamedb ‘×××1’,’×××2’：×××1是旧数据库名,×××2是新数据库名：更改数据库名称</li><li>sp_rename ‘xxx1’,’xxx1’:xxx1是旧表名,xxx2是新表名：更改表名称</li><li>sp_helptext xxxx：显示xxxx表的存储过程和其他对象的文本</li><li>sp_helpfile：查看数据库文件相关信息</li><li>sp_help:提供关于系统存储规程和其他数据库对象的报告</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql server管理</title>
      <link href="/2024/03/19/sql-server/"/>
      <url>/2024/03/19/sql-server/</url>
      
        <content type="html"><![CDATA[<h3 id="Sql-Server数据库操作"><a href="#Sql-Server数据库操作" class="headerlink" title="Sql Server数据库操作"></a>Sql Server数据库操作</h3><ul><li>master：基本配置</li><li>model：用建立数据库提供一个模型（可以设置初始化大小，后续建立就是指定） （创建文件默认为3MB，日志默认为512kb）</li><li>msdb:提供支持代理程序，产生一些监控信息</li><li>tempdb:临时的存储过程<br>16450-16460</li></ul><h3 id="命令行创建数据库"><a href="#命令行创建数据库" class="headerlink" title="命令行创建数据库"></a>命令行创建数据库</h3><p>create database business<br>on primary<br>(<br>    name&#x3D;<strong>,&#x2F;&#x2F;字段名字<br>    filename&#x3D;</strong>,&#x2F;&#x2F;物理存储路径<br>    size&#x3D;<strong>,&#x2F;&#x2F;初始大小<br>    maxsize&#x3D;</strong>,&#x2F;&#x2F;最大大小<br>    filegrwoth&#x3D;10% &#x2F;&#x2F;增幅<br>)<br>log on &#x2F;&#x2F;事务日志文件<br>(</p><p>)</p><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>name  字符类型,  age  整型<br>declare @name varchar(20), @age int</p><ul><li>赋值<ul><li>set @name&#x3D;’张三’</li><li>set @age&#x3D;’18’</li></ul></li><li>select 赋值  <ul><li>select @name&#x3D;’李四’,@age&#x3D;20</li></ul></li></ul><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><ul><li>cursor游标关键字</li><li>scroll表示可以对结果集任意位置进行操作</li><li>open打开游标</li><li>fetch表示游标读取</li><li>first表示读取第一行数据</li><li>next表示读取下一行数据</li><li>prior表示上一行数据</li><li>last表示读取最后一条数据</li><li>absolute 表示从游标的第一行开始, 直接跳到第n行</li><li>relative 表示相对当前游标的位置,进行跳转第n行<ul><li>declare my_cursor cursor scroll for select * from teacher(表示将游标声明在teacher表上)</li></ul></li><li>打开游标<ul><li>open my_cursor</li></ul></li><li>读取下一行数据<ul><li>fetch next from my_cursor(游标名字)</li></ul></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="/images/image.PNG" alt="Alt text"></p><h3 id="自定义无参函数"><a href="#自定义无参函数" class="headerlink" title="自定义无参函数"></a>自定义无参函数</h3><p>语法   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go   </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> first_func()[指前面是函数名]</span><br><span class="line"><span class="keyword">returns</span> <span class="type">varchar</span>(<span class="number">10</span>)[指前面是函数类型]</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;你好世界&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="自定义有参函数"><a href="#自定义有参函数" class="headerlink" title="自定义有参函数"></a>自定义有参函数</h3><ul><li>求某门课程的平均成绩语法<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go   </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> first_func(<span class="variable">@cn</span> <span class="type">varchar</span>(<span class="number">10</span>))[指前面是函数名]</span><br><span class="line"><span class="keyword">returns</span> <span class="type">float</span>[指前面是函数类型]</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">      <span class="keyword">declare</span> <span class="variable">@aver</span> <span class="type">float</span></span><br><span class="line">      <span class="keyword">select</span> <span class="variable">@aver</span><span class="operator">=</span><span class="built_in">avg</span>(score) <span class="keyword">from</span> sc <span class="keyword">where</span> cno<span class="operator">=</span><span class="variable">@cn</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;@aver&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="调用函数-函数名称前要加上架构名-dbo-更改后必须要执行才能保存"><a href="#调用函数-函数名称前要加上架构名-dbo-更改后必须要执行才能保存" class="headerlink" title="调用函数 函数名称前要加上架构名(dbo) 更改后必须要执行才能保存"></a>调用函数 函数名称前要加上架构名(dbo) 更改后必须要执行才能保存</h3><ul><li><p>使用select直接调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dbo.first_func()</span><br></pre></td></tr></table></figure></li><li><p>在语句块中调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable">@str</span> <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@str</span><span class="operator">=</span>dbo.first_func()</span><br><span class="line">print <span class="variable">@str</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="内嵌表值函数"><a href="#内嵌表值函数" class="headerlink" title="内嵌表值函数"></a>内嵌表值函数</h3><ul><li>创建内嵌表值查询某个专业所有学生的学号、姓名、所选的课程号和成绩<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> st_func(<span class="variable">@major</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">select</span> s.sno,sname,cno,score <span class="keyword">from</span> student s,sc <span class="keyword">where</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">and</span> sdept <span class="operator">=</span><span class="variable">@major</span></span><br><span class="line">go</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建多语句表值函数"><a href="#创建多语句表值函数" class="headerlink" title="创建多语句表值函数"></a>创建多语句表值函数</h3><ul><li>通过学号作为实参调用该函数,可显示改学生的姓名以及各门功课的成绩和学分<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> st_score(<span class="variable">@no</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="variable">@score</span> <span class="keyword">table</span></span><br><span class="line">(</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  score <span class="type">int</span>,</span><br><span class="line">  cre <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">insert</span> <span class="variable">@score</span> <span class="keyword">select</span> sname,score,credit <span class="keyword">from</span> student s,sc,cource c</span><br><span class="line">    <span class="keyword">where</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">and</span> c.cno <span class="operator">=</span> sc.cno <span class="keyword">and</span> s.sno<span class="operator">=</span><span class="variable">@no</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>set类</title>
      <link href="/2024/01/04/Collection%E7%9A%84set/"/>
      <url>/2024/01/04/Collection%E7%9A%84set/</url>
      
        <content type="html"><![CDATA[<h3 id="Set：存储无序的、不可重复的数据"><a href="#Set：存储无序的、不可重复的数据" class="headerlink" title="Set：存储无序的、不可重复的数据"></a>Set：存储无序的、不可重复的数据</h3><p>—-子接口：Set：存储无序的、不可重复的数据<br>    —- HashSet：主要实现类;底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储(jdk8中)<br>             —- LinkedHashSet(HashSet的子类):在现有的数组+单向链表+红黑树结构的基础上，又添加了一组双向链表，用于记录添加元素的先后顺序，即可以按照添加元素的顺序实现遍历，便于频繁的查询操作。<br>    —- TreeSet：底层使用红黑树存储，可以按照添加的元素的，指定的属性的大小顺序进行遍历。</p><h3 id="set中的无序性"><a href="#set中的无序性" class="headerlink" title="set中的无序性"></a>set中的无序性</h3><p>无序性:</p><ul><li>!&#x3D; 随机性   </li><li>添加元素的顺序和遍历元素的顺序不一致，是不是就是无序性？NO  </li><li>无序性指的是与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的   </li><li>这里是根据添加的元素的哈希值，计算的其在数组中的存储位置，此位置不是依次排列的，表现为无序性</li></ul><h3 id="不可重复性"><a href="#不可重复性" class="headerlink" title="不可重复性"></a>不可重复性</h3><ul><li>添加到Set中的元素是不能相同的，</li><li>比较的标准，需要判断hashCode()得到的哈希值与equals()得到的结果是否相同 </li><li>哈希值相同且equals()方法返回true,则认为元素是相同的</li></ul><h3 id="添加到HashSet-x2F-LinkedHashSet中元素的要求"><a href="#添加到HashSet-x2F-LinkedHashSet中元素的要求" class="headerlink" title="添加到HashSet&#x2F;LinkedHashSet中元素的要求"></a>添加到HashSet&#x2F;LinkedHashSet中元素的要求</h3><ul><li>要求元素所在的类要重写两个方法：equals()和hashCode()</li><li>同时,要求equals()和hashCode()要保持一致性,自动生成</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>List类</title>
      <link href="/2024/01/04/Collection%E7%9A%84list/"/>
      <url>/2024/01/04/Collection%E7%9A%84list/</url>
      
        <content type="html"><![CDATA[<h3 id="list：存储有序-可重复的数据-“动态数组”-父类：Collection"><a href="#list：存储有序-可重复的数据-“动态数组”-父类：Collection" class="headerlink" title="list：存储有序,可重复的数据(“动态数组”) 父类：Collection"></a>list：存储有序,可重复的数据(“动态数组”) 父类：Collection</h3><p>—–子接口：List：存储有序的、可重复的数据（“动态”数组）<br>    —- ArrayList：主要实现类<br>    —- LinkedList、Vector</p><ul><li><img src="/images/list.PNG" alt="Alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer和StringBuilder</title>
      <link href="/2023/12/26/StringBuffer%E5%92%8CStringBuilder/"/>
      <url>/2023/12/26/StringBuffer%E5%92%8CStringBuilder/</url>
      
        <content type="html"><![CDATA[<h3 id="三个类的对比-String、StringBuffer、StringBuilder"><a href="#三个类的对比-String、StringBuffer、StringBuilder" class="headerlink" title="三个类的对比:String、StringBuffer、StringBuilder"></a>三个类的对比:String、StringBuffer、StringBuilder</h3><ul><li>String：不可变字符序列,底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li><li>StringBuffer：可变字符序列；JDK1.0声明,线程安全的,效率低，底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li><li>StringBuilder：可变字符序列,JDK5.0声明,线程不安全的,效率高，底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li></ul><h3 id="StingBuffer和StringBuilder"><a href="#StingBuffer和StringBuilder" class="headerlink" title="StingBuffer和StringBuilder"></a>StingBuffer和StringBuilder</h3><p>内部的属性有:</p><ul><li>char[] value;&#x2F;&#x2F;存储字符序列</li><li>int count;&#x2F;&#x2F;实际存储的字符的个数</li></ul><p>StringBuilder sb &#x3D; new StringBuilder();&#x2F;&#x2F;char[] value &#x3D; new char[16];<br>当new一个StringBuilder时,会自动开辟一个16大小的字符空间</p><ul><li><p>如果字符大于原本的空间,超过value.length时,就需要扩容,默认扩容为原有容量的2倍+2,并将原油value数组中的元素赋值到新的数组中</p><pre><code>  增：append(xxx)  删：delete(int start,int end)  改：setCharAt(int n ,char ch) / replace(int start, int end, String str)  查：charAt(int n )  插：insert(int offset, xxx)  长度：length();</code></pre></li></ul><p>对比String、StringBuffer、StringBuilder三者的效率：</p><ul><li>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/2023/12/15/String%E7%B1%BB/"/>
      <url>/2023/12/15/String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="String类的理解（以JDK8为例说明）"><a href="#String类的理解（以JDK8为例说明）" class="headerlink" title="String类的理解（以JDK8为例说明）"></a>String类的理解（以JDK8为例说明）</h3><p>1.1<br>类的声明<br>public final class String<br>    inplementsjava.io.Serializable,Comparable<string>,CharSequence</p><blockquote><p>final:String是不可被继承的</p></blockquote><blockquote><p>SerializabLe：可序列化的接口。<br>凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输</p></blockquote><blockquote><p>ComparabLe：凡是实现此接口的类，其对象都可以比较大小。</p></blockquote><h3 id="内部声明的属性："><a href="#内部声明的属性：" class="headerlink" title="内部声明的属性："></a>内部声明的属性：</h3><p>private final char value[];&#x2F;&#x2F;存储字符串数据的容器</p><blockquote><p>final：指明此value数组一旦初始化，其地址就不可变。</p></blockquote><h3 id="字符串常量的存储位置"><a href="#字符串常量的存储位置" class="headerlink" title="字符串常量的存储位置"></a>字符串常量的存储位置</h3><blockquote><p>字符串常量都存储在字符串常量池(StringTable)中</p></blockquote><blockquote><p>字符串常量池不允许存放两个相同的字符串常量。</p></blockquote><blockquote><p>字符串常量池，在不同的dk版本中，存放位置不同。</p></blockquote><ul><li>jdk7之前：字符串常量池存放在方法区</li><li>jdk7及之后：字符串常量池存放在堆空间。</li></ul><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><ol><li><p>当对字符串变量重新赋值时,需要重新指定一个字符串常量的位置进行赋值,不能在原有的位置修改</p></li><li><p>当对现有的字符串进行拼接操作时,需要重新开辟空间保存<br>拼接以后的字符串,不能在原有的位置修改</p></li><li><p>当调用字符串的replace()替换现有的某个字符时,需要重新开辟空间保存<br>修改以后的字符,不能在原有的位置修改</p></li></ol><ul><li><p><img src="/images/String%E7%B1%BB.PNG" alt="Alt text"></p></li><li><p><img src="/images/String%E7%B1%BB2.PNG" alt="Alt text"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>同步锁</title>
      <link href="/2023/12/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%94%81/"/>
      <url>/2023/12/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="开启三个窗口售票-总票数为100张"><a href="#开启三个窗口售票-总票数为100张" class="headerlink" title="开启三个窗口售票,总票数为100张"></a>开启三个窗口售票,总票数为100张</h1><p>分别使用两种方式实现</p><p>1.多线程买票,出现的问题,出现了冲票和错票</p><p>2.什么原因导致? 线程1操作ticket的过程中,尚未结束的情况下,<br>其他线程也参与进来,对ticket进行操作</p><p>3.如何解决？ 必须保证一个线程a在操作ticket的过程中,其他线程必须<br>等待,直到线程必须等待,必须a结束后,其他才能进行操作ticket</p><p>4.java如何解决线程的安全问题的的？</p><h2 id="方式1-同步代码块"><a href="#方式1-同步代码块" class="headerlink" title="方式1:同步代码块"></a>方式1:同步代码块</h2><p>synchronized(同步监视器)<br>{<br>       &#x2F;&#x2F;需要被同步的代码<br>}</p><p>说明:</p><blockquote><p>需要被同步的代码，即为操作共享数据的代码</p></blockquote><blockquote><p>共享数据,即多个线程都需要操作的数据,比如：ticket</p></blockquote><blockquote><p>需要被同步的代码,在被synchronized包裹以后,就使得一个线程在操作这些代码的过程中，其他线程必须等待</p></blockquote><blockquote><p>同步监视器,俗称锁,谁获得了锁,谁就可以执行</p></blockquote><blockquote><p>同步监视器,可以使用任何一个类的对象充当,但是,多个线程必须共用同一个类</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul><li>在实现Runnable接口的方式中，同步监视器可以考虑使用:this</li><li>在继承Thread类方法中,同步监视器要慎用this,可以使用当前类.class</li></ul><h2 id="方式2-同步方法"><a href="#方式2-同步方法" class="headerlink" title="方式2:同步方法"></a>方式2:同步方法</h2><p>说明：如果操作共享数据的代码完整的声明在一个方法中,就可以将此方法声明为同步方法即可</p><blockquote><p>非静态的同步方法:默认同步监视器是this<br>静态的同步方法:默认同步监视器是当前类的本身</p></blockquote><p>synchronized好处:解决了线程的安全问题</p><p>弊端：在操作共享数据时,多线程其实是串行执行的,意味着性能低</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建线程</title>
      <link href="/2023/12/12/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/12/12/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的创建方式-继承Thread类"><a href="#线程的创建方式-继承Thread类" class="headerlink" title="线程的创建方式:继承Thread类"></a>线程的创建方式:继承Thread类</h3><p>步骤：   </p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()—&gt; 将此线程要执行的操作,声明在此方法体中</li><li>创建当前Thread的子类的对象</li><li>通过对象调用父类的start()类</li></ol><h3 id="线程的创建方式二-实现Runnable接口"><a href="#线程的创建方式二-实现Runnable接口" class="headerlink" title="线程的创建方式二:实现Runnable接口"></a>线程的创建方式二:实现Runnable接口</h3><p>步骤：</p><ol><li>创建一个实现Runnable接口的类</li><li>实现接口中run() —&gt;将此线程要执行的操作,声明在此方法体中</li><li>创建当前实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中,常见Thread类的实例</li><li>Thread类的实例调用start():启动线程和调用当前线程的run()</li></ol><h3 id="对比两种方法"><a href="#对比两种方法" class="headerlink" title="对比两种方法"></a>对比两种方法</h3><p>共同点:</p><ol><li>启动线程,使用的都是Thread类中定义的start()</li><li>创建的线程对象,都是Thread类或其子类的实例</li></ol><p>不同点:一个是类的继承,一个是接口的实现</p><p>优先使用:Runnable方法，因为：</p><ol><li>实现的方法,避免类单继承的局限性</li><li>更适合处理有共享数据的问题</li><li>实现了代码和数据的分离</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义异常类</title>
      <link href="/2023/12/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/"/>
      <url>/2023/12/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>如何自义定异常类?</li></ol><ul><li><p>继承与现有异常体系,通常继承与RuntimeException&#x2F;Exception</p></li><li><p>通常提供几个重载构造器</p></li><li><p>提供一个全局常量,声明为,</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID=-<span class="number">155465813</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>如何使用自定义异常类?</li></ol><ul><li>在具体的代码中,满足指定条件的情况,使用”throw + 自定义异常类的对象”</li></ul><ol start="3"><li>为什么要自定义异常类?</li></ol><ul><li>我们其实更关心的通过异常的名称就能直接判断异常的原因,见名知意。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Throws异常</title>
      <link href="/2023/12/08/Throws/"/>
      <url>/2023/12/08/Throws/</url>
      
        <content type="html"><![CDATA[<h2 id="Throws异常"><a href="#Throws异常" class="headerlink" title="Throws异常"></a>Throws异常</h2><ol><li><p>格式：在方法的声明处，使用throws 异常类型1,异常类型2，…</p></li><li><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test <span class="keyword">throws</span> 异常类型<span class="number">1</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//可能存在编译时异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>是否真正处理了异常？</p></li></ol><ul><li>从编译是否能通过的角度看，给出了异常的解决方案,此解决方案就是向上抛出<br>但是,此throws的方式,仅可能出现的异常抛给调用者,不是真正的处理了异常。</li></ul><ol start="4"><li>方法重写的要求？</li></ol><ul><li>子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法的异常类型的子类。</li><li>简单来说,就是子类抛出的异常必须是父类抛出的子类或者跟父类一样的方法。</li></ul><ol start="5"><li>开发中,如何选择异常处理的两种方式？</li></ol><ul><li><p>资源一定要执行,try-catch-finally</p></li><li><p>重写,try-catch-finally</p></li><li><p>开发中,方法a调用了b,c,d方法,b,c,d使用throws异常处理,而a方法使用try-catch-finally</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Finally</title>
      <link href="/2023/12/07/Finally/"/>
      <url>/2023/12/07/Finally/</url>
      
        <content type="html"><![CDATA[<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>使用：将一定会被执行的代码放在finally中</p><ol><li><p>finally是可选的   </p></li><li><p>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p></li><li><p>什么情况下需要使用Finally</p></li></ol><ul><li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>包装类</title>
      <link href="/2023/12/04/%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2023/12/04/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li><img src="/images/%E5%8C%85%E8%A3%85%E7%B1%BB.PNG" alt="Alt text"></li></ul><ol><li>为什么使用包装类？</li></ol><ul><li>为了使得基本类型的变量具备引用数据类型变量的相关特性(比如:封装,继承,多态)</li></ul><ol start="2"><li>为什么需要装换基本数据类型与包装类之间的转换</li></ol><ul><li>一方面:在有些场景下,需要使用基本数据类型对象的包装类的对象,就需要转</li><li>另一方面:对于包装类,都是对象,对象不能 + - * &#x2F;运算,就需要转</li></ul><ol start="3"><li>基本数据类型 –&gt;包装类</li></ol><ul><li>使用包装类的构造器</li><li>使用valueOf()</li></ul><ol start="4"><li>包装类型 –&gt;基本数据类型</li></ol><ul><li>使用xxxValue()</li></ul><ol start="5"><li>基本数据类型 包装类  –&gt; String类型</li></ol><ul><li>调用String的重载的静态方法valueof(xxx xx)</li></ul><ol start="6"><li>String类型 –&gt; 基本数据类型 包装类</li></ol><ul><li>调用包装类的静态方法:parseXXX(),例如:Integer.parseInt();</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUnit</title>
      <link href="/2023/12/04/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-jUnit/"/>
      <url>/2023/12/04/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-jUnit/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试JUnit"><a href="#单元测试JUnit" class="headerlink" title="单元测试JUnit"></a>单元测试JUnit</h1><p>步骤：</p><ol><li>选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下</li><li>创建Java类，进行单元测试。<br>  此时的Java类要求：<br>  ① 此类是public的<br>  ②此类提供公共的无参的构造器</li><li>此类中声明单元测试方法。<br>  此时的单元测试方法：方法的权限是  public,没有返回值，没有形参   </li><li>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.  junit.Test;  </li><li>声明好单元测试方法以后，就可以在方法体内测试相关的代码。   </li><li>写完代码以后，左键双击单元测试方法  名，右键：run as - JUnit Test<br>说明：  </li><li>如果执行结果没有任何异常：绿条  </li><li>如果执行结果出现异常：红条</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/12/03/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/12/03/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>理解: 枚举类型本质也是一种类,只不过这个类的对象是有限的,固定的几个,不能让用户随意创建。</p><ol><li><p>举例:</p><ul><li>‘星期’:星期一到星期日</li><li>‘性别’:男,女</li><li>‘月份’:1月到12月</li><li>‘季节’:春夏秋冬</li></ul></li><li><p>开发中：</p><ul><li>如果针对某个类,其实例是确定个数的,则推荐此类声明为枚举类</li><li>如果枚举类的实例只有一个,则可以看做是单例的实现方式</li></ul></li><li><p>常用方法:</p><ul><li>String toString()：默认返回的是常量名</li><li>static 枚举类型[] valuse();：返回枚举类型的对象数组</li><li>static 枚举类型 valueOf(String name)：</li><li>String name():得到当前枚举常量的名称</li><li>int ordinal():返回当前枚举常量的序号,默认从0开始</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2023/12/02/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2023/12/02/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ol><li>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类   </li><li>内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)</li><li>成员内部类：<ul><li>一方面，作为外部类的成员：<br>  调用外部类的结构<br>  &gt;可以被static修饰<br>  &gt;可以被4种不同的权限修饰    </li><li>另一方面，作为一个类：<br>  &gt; 类内可以定义属性、方法、构造器等<br>  &gt; 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承<br>  &gt; 可以被abstract修饰</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/11/30/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/11/30/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><ul><li>接口:接口的本质是契约,标准,规范,就像我们的法律一样,制定好后大家都要遵守。</li></ul><ol><li><p>接口使用interface来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ul><li>3.1 JDK7及以前：只能定义全局常量和抽象方法</li><li>全局常量：public static final的.但是书写时，可以省略不写</li><li>抽象方法：public abstract的</li><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li></ul></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p></li></ol><ul><li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li></ul><ol start="6"><li><p>Java类可以实现多个接口<br>  弥补了Java单继承性的局限性<br>  格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性<br>多态性:接口名 变量名 &#x3D; new 实现类对象;</p></li><li><p>面试题:区分抽象类和接口</p></li></ol><p>共性：</p><ul><li>都可以声明抽象方法</li><li>都不能实例化</li></ul><p>不同：</p><ul><li>抽象类一定有构造器,接口没有构造器</li><li>类与类之间继承关系,类与接口之前是实现关系,接口与接口是多继承关系</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和抽象方法</title>
      <link href="/2023/11/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h1><ol><li><p>abstract:抽象的</p></li><li><p>abstract可以用来修饰的结构：类、方法</p></li><li><p>abstract修饰类：抽象类</p><ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</li></ul></li><li><p>abstract修饰方法：抽象方法</p><ul><li>抽象方法只有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所有的抽象方法后，此子类方可实例化</li><li>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul></li><li><p>不能用abstract修饰私有方法，静态方法，final的方法和final类</p></li></ol><ul><li>私有方法不能被重写</li><li>避免静态方法使用类进行调用</li><li>final方法不能被重写</li><li>final类不能有子类</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Final类</title>
      <link href="/2023/11/30/Final/"/>
      <url>/2023/11/30/Final/</url>
      
        <content type="html"><![CDATA[<h1 id="Final-最终的-常量"><a href="#Final-最终的-常量" class="headerlink" title="Final:最终的,(常量)"></a>Final:最终的,(常量)</h1><ol><li><p>final可以用来修饰的结构：类、方法、变量</p></li><li><p>final 用来修饰一个类:此类不能被其他类所继承。<br>  比如：String类、System类、StringBuffer类</p></li><li><p>final 用来修饰方法：表明此方法不可以被重写<br>     比如：Object类中getClass();</p></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>inal修饰属性：可以考虑赋值的位置有：<ul><li>显式初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul></li><li>final修饰局部变量：<br>尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li></ol><p> static final 用来修饰属性：全局常量</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态代码块</title>
      <link href="/2023/11/29/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2023/11/29/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><p>作用:用来初始化类或对象的信息</p><ol><li>代码块的修饰</li></ol><ul><li>只能使用static进行修饰</li></ul><ol start="2"><li>代码块的分类</li></ol><ul><li>静态代码块:使用static修饰</li><li>非静态代码块:没有使用static修饰</li></ul><ol start="3"><li>具体使用</li></ol><ul><li><p>静态代码块:<br>  1.随着类的加载而执行。<br>  2.随着类的加载只会执行一次,静态代码块也只会执行一次。<br>  3.作用：用来初始化类的信息<br>  4.内部可以声明变量,调用属性或方法,编写输出语句等操作<br>  5.静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构。   </p></li><li><p>非静态代码块:<br>  1.随着对象的创建而执行。<br>  2.每创建当前类的一个实例,就会执行一次代码块。<br>  3.作用：用来初始化对象的信息。<br>  4.内部可以声明变量,调用属性或方法,编写输出语句等操作。<br>  5.如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行。<br>  6.非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2023/11/29/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/11/29/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>概念：采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法</p><ol><li><p>23种设计模式<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4.PNG" alt="Alt text"></p></li><li><p>如何实现单例模式?</p></li></ol><ul><li><p>饿汉式</p></li><li><p>懒汉式</p></li></ul><ol start="3"><li>对比两种模式(特点)</li></ol><ul><li>饿汉式:”立即加载”,随着类的加载,当前的唯一实例就创建了</li><li>懒汉式:”延迟加载”,在需要使用的时候,进行创建</li></ul><hr><p>优缺点:</p><ul><li>饿汉式(优点):写法简单,由于内存中较早加载,使用方便,快,线程安全</li><li>饿汉式(缺点):内存中占用时间较长</li><li>懒汉式(优点):在需要使用的时候,进行创建,节省内存空间</li><li>懒汉式(缺点):线程不安全</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2023/11/27/Object%E7%B1%BB/"/>
      <url>/2023/11/27/Object%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Object类-java-lang-Object类"><a href="#Object类-java-lang-Object类" class="headerlink" title="Object类(java.lang.Object类)"></a>Object类(java.lang.Object类)</h1><ol><li><p>Object类是所有Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p></li><li><p>Object类中的功能(属性、方法)就具有通用性。</p></li><li><p>方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()<br> wait() 、 notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参的构造器</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多态性</title>
      <link href="/2023/11/21/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
      <url>/2023/11/21/%E5%A4%9A%E6%80%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><ol><li><p><strong>多态性？</strong></p><p>理解：理解为一个事物的多种形态</p></li><li><p><strong>java中多态性的体现？</strong>   </p><p>子类对象的多态性:父类的引用指向子类的对象。<br>比如：Person p2 &#x3D; new Man();</p></li><li><p><strong>多态性的应用？</strong>  </p><p>简称为:编译看左边,运行看右边</p></li><li><p><strong>多态性使用场景</strong></p><ul><li>要有类的继承关系</li><li>要有重写的方法</li></ul></li></ol><ul><li>属性不满足多态性</li></ul><ol start="5"><li><p><strong>多态适用性</strong></p><ul><li>适用于方法,不适用与属性</li></ul></li><li><p><strong>多态的好处</strong></p><ul><li>极大的减少了代码的冗余,不需要定义多个重载的方法</li></ul></li><li><p><strong>多态的弊端</strong></p><ul><li>Person p2 &#x3D; new Man();<br>针对于创建的对象,在内存中是否加载Man类中声明的特有属性和方法？    答：加载了！</li><li>能不能直接调用Man中加载的属性和方法？<br>答：不能</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Static关键字</title>
      <link href="/2023/11/20/Static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/11/20/Static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h1><ul><li>静态变量和静态方法</li><li>如果想让一个成员变量被类的所有是实例所共享,就用static修饰即可,即为类变量(类属性)!</li><li><img src="/images/Static%E5%86%85%E5%AD%98.PNG" alt="Alt text"></li><li><img src="/images/Static%E5%86%85%E5%AD%982.PNG" alt="Alt text"></li></ul><ol><li><p>static:静态的</p></li><li><p>static可以用来修饰：属性、方法、代码块、内部类</p></li><li><p>使用static修饰属性：静态变量（或类变量）<br> 3.1 属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p><ul><li><strong>实例变量</strong>：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li><strong>静态变量</strong>：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul></li><li><p>static修饰属性的其他说明：</p><ul><li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建。</p></li><li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p><pre><code>   类变量实例变量类yes    no对象yesyes</code></pre></li></ul><p>  3.3 静态属性举例：System.out; Math.PI;</p></li><li><p>使用static修饰方法：静态方法</p><ul><li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用 </p></li><li><p>静态方法中，只能调用静态的方法或属性    </p></li><li><p>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></li></ul></li><li><p>开发中，如何确定一个属性是否要声明为static的？   </p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul><p>开发中，如何确定一个方法是否要声明为static的？<br>    &gt; 操作静态属性的方法，通常设置为static的</p><blockquote><p>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</p></blockquote></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Super关键字</title>
      <link href="/2023/11/20/Super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/11/20/Super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="super关键字使用"><a href="#super关键字使用" class="headerlink" title="super关键字使用"></a>super关键字使用</h1><ol><li>super理解为：父类的</li><li>super可以用来调用：属性、方法、构造器</li></ol><h1 id="super的使用：调用属性和方法"><a href="#super的使用：调用属性和方法" class="headerlink" title="super的使用：调用属性和方法"></a>super的使用：调用属性和方法</h1><ol><li><p>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用<br>  父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p></li><li><p>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的<br>  使用”super.属性”的方式，表明调用的是父类中声明的属性。  </p></li><li><p>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的<br>  使用”super.方法”的方式，表明调用的是父类中被重写的方法。</p></li></ol><h1 id="super调用构造器"><a href="#super调用构造器" class="headerlink" title="super调用构造器"></a>super调用构造器</h1><ol><li><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器   </p></li><li><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p></li><li><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现   </p></li><li><p>在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()   </p></li><li><p>在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p></li></ol><h1 id="super案例"><a href="#super案例" class="headerlink" title="super案例"></a>super案例</h1><ol><li><p><img src="/images/super%E6%A1%88%E4%BE%8B.PNG" alt="Alt text"><br>运行结果:<br> A<br> B<br> A<br> AB<br>当子类继承父类,子类中必须有一个super()关键字的空参或者指定的实参</p></li><li><p><img src="/images/super%E6%A1%88%E4%BE%8B2.PNG" alt="Alt text"><br>运行结果：<br><img src="/images/super2%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="Alt text"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>继承性</title>
      <link href="/2023/11/16/%E7%BB%A7%E6%89%BF%E6%80%A7/"/>
      <url>/2023/11/16/%E7%BB%A7%E6%89%BF%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h1><pre><code>1. 自上而下:定义一个类A,在定义另一个类时,发现类B的功能与类A相似,考虑B继承于A  2. 自下而上:定义类B,C,D有类似的属性和方法,则可以考虑相同的属性和方法进行抽取,封装到类A中,让类B,C,D继承于类A，同时,B,C,D中的相似的功能就可以删除。</code></pre><h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><p>   ① 减少了代码的冗余，提高了代码的复用性<br>   ② 便于功能的扩展<br>   ③ 为之后多态性的使用，提供了前提</p><h2 id="继承性的格式："><a href="#继承性的格式：" class="headerlink" title="继承性的格式："></a>继承性的格式：</h2><pre><code>class A extends B&#123;&#125;A:子类、派生类、subclassB:父类、超类、基类、superclass</code></pre><ul><li>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。   <ul><li>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。</li><li>只有因为封装性的影响，使得子类不能直接调用父类的结构而已。</li><li>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</li><li>子类和父类的关系，不同于子集和集合的关系。</li></ul></li></ul><h2 id="Java中关于继承性的规定："><a href="#Java中关于继承性的规定：" class="headerlink" title="Java中关于继承性的规定："></a>Java中关于继承性的规定：</h2><pre><code> 1. 一个父类可以被多个子类继承,一个子类不能继承多个父类2. Java中类的单继承性：一个类只能有一个父类3. 子父类是相对的概念。4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类5. 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</code></pre><h2 id="继承的关系"><a href="#继承的关系" class="headerlink" title="继承的关系"></a>继承的关系</h2><ol><li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类  </li><li>所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类  </li><li>意味着，所有的java类具有java.lang.Object类声明的功能。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>try_catch异常</title>
      <link href="/2023/09/25/try-catch/"/>
      <url>/2023/09/25/try-catch/</url>
      
        <content type="html"><![CDATA[<h1 id="try-catch异常"><a href="#try-catch异常" class="headerlink" title="try_catch异常"></a>try_catch异常</h1><h2 id="异常的处理：抓抛模型"><a href="#异常的处理：抓抛模型" class="headerlink" title="异常的处理：抓抛模型"></a>异常的处理：抓抛模型</h2><h4 id="过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。"><a href="#过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。" class="headerlink" title="过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。"></a>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</h4><ul><li>关于异常对象的产生：<br>① 系统自动生成的异常对象<br>② 手动的生成一个异常对象，并抛出（throw）</li></ul><h4 id="过程二：”抓”：可以理解为异常的处理方式："><a href="#过程二：”抓”：可以理解为异常的处理方式：" class="headerlink" title="过程二：”抓”：可以理解为异常的处理方式："></a>过程二：”抓”：可以理解为异常的处理方式：</h4><p>① try-catch-finally<br>② throws<br>二、try-catch-finally的使用   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>finally是可选的。</li><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配   </li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的<br>try-catch结构（在没有写finally的情况）。继续执行其后的代码</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。<br>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 </li><li>常用的异常对象处理的方式：<br> ① String  getMessage()获取发生异常的原因<br> ② printStackTrace()打印异常的详细信息</li><li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li><li>try-catch-finally结构可以嵌套</li></ol><ul><li>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</li><li>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</li></ul><h4 id="对于运行时异常"><a href="#对于运行时异常" class="headerlink" title="对于运行时异常:"></a>对于运行时异常:</h4><ul><li>开发中，通常就不进行显示的处理了<br>一旦在程序执行中，出现了运行时异常，那么就根据异常的提示信息修改代码即可</li></ul><h4 id="对于编译时异常："><a href="#对于编译时异常：" class="headerlink" title="对于编译时异常："></a>对于编译时异常：</h4><p>一定要进行处理，否则编译不通过</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="/2023/09/25/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/09/25/this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p>this是一个关键字，是一个引用，是一个变量，保存内存地址指向自身。</p><p>this可以使用在实例方法中，也可以使用在构造方法中。</p><p>this出现在实例方法中其实代表的是当前对象。</p><p>this不能使用在静态方法中。因为静态方法是类级别的方法。</p><p>this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。</p><p>this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用</p><ol><li>this调用构造器</li></ol><p>格式:”this(形参列表)”</p><p>我们可以在类的构造器中,调用当前类中指定的其他构造器</p><p>要求:”this(形参列表)”必须声明在当前构造器的首行</p><p>结论:”this(形参列表)”在构造器中最多声明一个</p><p>如果一个类中声明了n个构造器,则最多有n-1构造器可以声明有this(形参列表)的结构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构造器</title>
      <link href="/2023/09/24/%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2023/09/24/%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="构造器-constructor"><a href="#构造器-constructor" class="headerlink" title="构造器(constructor)"></a>构造器(constructor)</h1><ol><li>构造器的理解<br>构造器是处于Java类中的一个方法,最大的作用创建对象时执行初始化</li><li>构造器的作用</li></ol><ul><li>作用1：搭配new关键字,创建类的对象</li><li>作用2：在创建对象的同时,可以给对象的相关属性赋值</li></ul><ol start="3"><li>构造器的使用说明</li></ol><ul><li>构造器的声明的格式:权限修饰符  类名(形参列表)<br>{}<blockquote><p>创建类以后,在没有显示提示任何构造器的情况下,系统会默认提供一个空参的构造器,且构造器的权限与类声明的权限相同<br>一旦类中显示声明了构造器,则系统不再提供默认的空参的构造器<br> 一个类中可以声明多个构造器,彼此之间构成重载</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>封装性</title>
      <link href="/2023/09/21/%E5%B0%81%E8%A3%85%E6%80%A7/"/>
      <url>/2023/09/21/%E5%B0%81%E8%A3%85%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h1><blockquote><p>把客观事物封装成抽象概念类,并且类可以把自己的数据和方法指向可信的类或者对象开放,向没必要开放的类或者对象隐藏信息<br><strong>通俗的讲,就是把该隐藏的隐藏,该暴露的暴露出来,这就是封装性的设计思想</strong></p></blockquote><p>面向对象的开发原则要遵循<strong>高内聚,低耦合</strong></p><ul><li>高内聚:类的内部数据操作细节自己完成,不允许外部干涉(java程序通常以类的形态呈现,相关的功能封装到方法中)</li><li>低耦合:仅暴露少量的方法给外部使用,尽量方便外部调用</li></ul><h1 id="如何使用数据封装"><a href="#如何使用数据封装" class="headerlink" title="如何使用数据封装"></a>如何使用数据封装</h1><ul><li><p>java规定了4种权限修饰,分别是:private，缺省,protected,public</p></li><li><p>四种使用权限<br><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%904.PNG" alt="Alt text"></p></li></ul><blockquote><p>类，只能使用public,缺省<br>类的内部成员,可以使用4种权限修饰进行修饰</p></blockquote><ul><li>作用：可以使用4种权限修饰类的内部成员,当成员被调用时,体现可见性的大小</li></ul><h1 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h1><blockquote><p>场景1:私有化(private)类的属性,提供公共(public)的gei和set方法,对此属性进行获取或修改<br>场景2:将类中不需要对外暴露的方法,设置为private<br>场景3:单列模式种构造器private的,避免在类的外部创建实例</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>package和import</title>
      <link href="/2023/09/21/package%E5%92%8Cimport%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/21/package%E5%92%8Cimport%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="package关键词的使用"><a href="#package关键词的使用" class="headerlink" title="package关键词的使用"></a>package关键词的使用</h1><blockquote><p>package: 包</p></blockquote><blockquote><p>package用于指明该文件中定义的类,接口等结构所在的包</p></blockquote><blockquote><p>一个源文件只能有一个声明包的package语句,且必须放在第一条语句出现,若缺省,则为无名包,取报名不能使用java.xxx</p></blockquote><h1 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h1><ul><li>可以包含类和子包,划分项目层次,便于管理</li><li>帮助管理大型软件系统,将功能相近的类划分到同一个包中</li><li>解决类命名冲突问题</li><li>控制访问权限</li></ul><h1 id="import关键字的使用"><a href="#import关键字的使用" class="headerlink" title="import关键字的使用"></a>import关键字的使用</h1><blockquote><p>import:导入<br>import语句来显示引入指定包下所需要的类,相当于import语句告诉编译器到哪去寻找这个类<br>import语句,声明在包的声明和类的声明之间</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重载</title>
      <link href="/2023/09/20/%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/09/20/%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><ol><li><p>定义:<br>指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。调用重载方法时，方法重载通常用于创建完成一组任务相似但参数的类型或参数的个数或参数的顺序不同的方法，Java的方法重载，就是在类中可以创建多个方法，它们可以有相同的名字，但必须具有不同的参数，即或者是参数的个数不同，或者是参数的类型不同。调用方法时通过传递给它们的不同个数和类型的参数，以及传入参数的顺序来决定具体使用哪个方法。</p></li><li><p>总结:两同一不同</p></li></ol><ul><li>两同:同一个类,相同的方法名</li><li>一不同:参数列表不同:1 参数个数不同,2 参数类型不同<br>注意:方法的重载与形参的名,权限修饰符,返回值类型都没有关系</li></ul><h1 id="可变个数形参的方法"><a href="#可变个数形参的方法" class="headerlink" title="可变个数形参的方法"></a>可变个数形参的方法</h1><ol><li><p>使用场景:在调用方法时,可能会出现方法形参的类型是确定的,但是参数的个数不确定,此时,我们就可以使用可变个数形参的方法</p></li><li><p>格式:(参数类型 …参数名)</p></li><li><p>说明：</p></li></ol><ul><li>在被调用时,可变个数的可以为:0个,1个或多个</li><li>可变个数的方法与同一个类中,同名的多个方法之前可以构成重载</li><li>特例:可变个数的形参的方法与同一个类中方法名相同,且与可变个数形参的类型相同的数组参数不构成重载</li><li>可变个数的形参必须声明在形参列表的最后</li><li>可变个数的形参最多在一个方法的形参列表中出现一次</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句</title>
      <link href="/2023/09/19/%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/19/%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li><strong>方法</strong>是类或对象行为特征的抽象,用来完成某个功能操作,在某些语言中称为<strong>函数</strong>或者<strong>过程</strong></li><li>将功能封装为方法的目的是,可以实现<strong>代码重用,减少冗余,简化代码</strong></li><li>java里的方法不能独立存在,所有的方法必须定义在类里</li></ul><hr><h1 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h1><p>权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]<br>{<br>&#x2F;&#x2F;方法头<br>&#x2F;&#x2F;方法体<br>}<br>注意:[]中的内部不是必须的</p><h1 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h1><p>含义:描述当调用玩此方法时,是否需要返回一个结果</p><p>分类:</p><ol><li>无返回值类型,使用void表示即可</li><li>有具体的返回值类型,需要指明返回的数据的类型,可以是基本数据类型,可以是引用数据类型</li></ol><ul><li>需要在方法内部配合使用:”return + 返回值类型的变量或者常量”</li></ul><ol start="3"><li>内存解析<br><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%904.PNG" alt="Alt text"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>局部变量和成员变量</title>
      <link href="/2023/09/14/%E6%88%90%E5%91%98%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
      <url>/2023/09/14/%E6%88%90%E5%91%98%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol><li>变量的分类</li></ol><ul><li>角度一:按照数据类型来分:基本数据类型(8种),引用数据类型(数组、类、接口、枚举、注解、记录)</li><li>角度二:按照变量在类中声明的位置不同,成员变量(或属性)、局部变量( 方法内、方法形参、构造器内、)</li></ul><ol start="2"><li><p>属性的几个称谓:成员变量、属性、field(字段、域)</p></li><li><p>区分  成员变量 vs 局部变量<br>相同点:</p></li></ol><ul><li>变量格式声明相同</li><li>变量都有其有效的作用域,出了作用域就失效了</li><li>变量必须先声明后赋值在使用</li></ul><p>不同点:</p><ol><li>类中声明的位置不同</li></ol><ul><li>属性:声明在类内,方法外的变量</li><li>局部变量:声明方法、构造器内部的变量</li></ul><ol start="2"><li>在内存中分配的位置不同</li></ol><ul><li>属性:随着对象的创建,存储在堆空间中</li><li>局部变量:存储在栈空间中</li></ul><ol start="3"><li>声明周期</li></ol><ul><li>属性:随着对象的创建而创建,随着对象的消亡而消亡</li><li>局部变量:s<br>  随着方法对应的栈帧入栈,局部变量会在栈中分配,随着方法对应的栈帧出栈,局部变量消亡</li></ul><ol start="4"><li>作用域</li></ol><ul><li>属性:在整个类的内部都是有效的</li><li>局部变量:仅限于声明此局部变量所在的方法(构造器,代码块)中</li></ul><ol start="5"><li>是否可以有权限修饰符进行修饰</li></ol><ul><li>public,protected,缺省,private(用于表明所修饰的结构可调用的范围的大小)</li><li>属性:是可以使用权限修饰符进行修饰的</li><li>局部变量(方法):不可以使用任何权限修饰符进行修饰的</li></ul><ol start="6"><li>是否有默认值</li></ol><ul><li>属性:都有默认初始化值<br>  意味着,如果没有给属性进行显示初始化赋值,则会有默认初始化值</li><li>局部变量:都没有默认初始化值<br>  意味着,在使用局部变量之前,必须要显示的赋值,否则报错<br>  注意:对于方法的形参而言,在调用方法时,给此形参赋值</li></ul><h2 id="实参给形参赋值的过程"><a href="#实参给形参赋值的过程" class="headerlink" title="实参给形参赋值的过程"></a>实参给形参赋值的过程</h2><blockquote><p>如果形参是基本数据类型的变量,则将实参保存的数据值赋给形参<br>如果形参是引用数据类型的变量,则将实参保存的地址值赋给形参</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/09/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/09/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>java类及类的成员:(重点)属性,方法,构造器,(熟悉)代码块,内部类</li><li>面向对象的特征:封装、继承、多态、(抽象)</li><li>其他关键字的使用:this、super、package、import、static、final、interface、abstract</li></ul><h1 id="面向对象编程概述"><a href="#面向对象编程概述" class="headerlink" title="面向对象编程概述"></a>面向对象编程概述</h1><p>有指令式编程和函数式编程,主要包括面向过程和面向对象</p><h2 id="java基本元素-类和对象"><a href="#java基本元素-类和对象" class="headerlink" title="java基本元素:类和对象"></a>java基本元素:类和对象</h2><p><strong>类</strong>(Class)和<strong>对象</strong>(Object)是面向对象的核心概念</p><p>类</p><ul><li><p>具有相同特征的事物的抽象描述,是<strong>抽象</strong>的,概念上的定义<br>对象</p></li><li><p>实际存在的该类事物的<strong>每个个体</strong>,是<strong>具体的</strong>,因此称为实例 </p></li><li><p><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.PNG" alt="Alt text"></p></li></ul><p>类的实例化</p><ul><li>等价描述:类的实例化&lt;&#x3D;&#x3D;&gt;创建类的对象</li><li>格式:类的类型 对象名 &#x3D; 通过new创建的对象实体</li><li>举例:<br>Phone p1 &#x3D; new Phone();<br>Scanner scan &#x3D; new Scanner(System.in);</li></ul><p>面向对象完成具体共鞥的操作的三步流程(非常重要)</p><ul><li>创建类，并设计类的内部成员(属性、方法)</li><li>创建类的对象,比如:Phone p1 &#x3D; new Phone();</li><li>通过对象,调用其内部声明的属性或方法,完成相关功能</li></ul><p>对象在内存中的分配涉及到的内存结构</p><ul><li>栈:方法内定义的变量,存储在栈中</li><li>堆:new 出来的结构(比如:数组实体、对象的实体),包括对象中的属性</li><li>方法区:存放类的模板,比如:Person类的模版</li></ul><p>栈堆内存图解析:</p><ul><li><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%901.PNG" alt="Alt text"></li><li><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%902.PNG" alt="Alt text"></li><li><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%903.PNG" alt="Alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>arrays类</title>
      <link href="/2023/09/13/Arrays%E7%B1%BB/"/>
      <url>/2023/09/13/Arrays%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>处在Java.util包下</p><p>作用:java.util.Arrays类即为操作数组的工具类,包含了用来操作数组(比如排序和搜索)的各种方法</p><hr><p>Arrays的常用方法   </p><p>1. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span>:比较两个数组的元素是否依次相等</span><br><span class="line">例:<span class="type">boolean</span> isEquals=Arrays.equals(arr1,arr2);</span><br></pre></td></tr></table></figure><p>2. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] a)</span>:输出数组元素信息</span><br><span class="line">例:System.out.println(Arrays.toString(arr1))</span><br></pre></td></tr></table></figure><p>3. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] val)</span>:将指定值填充到数组之中</span><br><span class="line">例:System.out.println(Array.fill(arr1,<span class="number">10</span>));</span><br><span class="line">这条代码意思是调用fill方法,将arr1数组所有的值改为<span class="number">10</span></span><br></pre></td></tr></table></figure><p>4. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span>:使用快速排序算法实现的升序排序</span><br><span class="line">例:System.out.println(Arrays.sort(arr3))</span><br><span class="line">例:实现降序的sort方法时,不能使用<span class="type">int</span>类型了,要用integer,<span class="type">float</span>要使用Float,不能使用基本类型,</span><br><span class="line">Arrays.sort(arr3,Collections.reverseOrder())</span><br></pre></td></tr></table></figure><p>5. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> key)</span>:二分查找</span><br><span class="line"><span class="comment">//使用前提,当前数组是有序的,当找到了显示索引值,没找到显示负数</span></span><br><span class="line">例:<span class="type">int</span> index=Arrays.binarySearch(arr3,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序查找和二分查找</title>
      <link href="/2023/09/13/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
      <url>/2023/09/13/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><ul><li>优点：算法简单</li><li>缺点:执行效率低,执行的时间复杂度O(N)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Linear_Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">34</span>, <span class="number">54</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">65</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">76</span>, <span class="number">34</span>, <span class="number">67</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//        boolean flag=true;</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; arr1.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//           if (x==arr1[i])&#123;</span></span><br><span class="line"><span class="comment">//               System.out.println(&quot;索引&quot;+x+&quot;已经找到,位置为&quot;+i);</span></span><br><span class="line"><span class="comment">//               flag = false;</span></span><br><span class="line"><span class="comment">//               break;</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (flag) System.out.println(&quot;没有找到此元素&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr1[i]) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;索引&quot;</span> + x + <span class="string">&quot;已经找到,位置为&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == arr1.length) System.out.println(<span class="string">&quot;没有找到此元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h1><ul><li>优点:执行效率高,执行的时间复杂度O(logN)</li><li>缺点:算法相较于顺序查找难一点,数组必须有序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binary_Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">26</span>,<span class="number">37</span>,<span class="number">49</span>,<span class="number">51</span>,<span class="number">66</span>,<span class="number">89</span>,<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=<span class="number">5</span>;<span class="comment">//要查找的元素</span></span><br><span class="line"><span class="comment">//        target=17;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>;<span class="comment">//首值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr2.length;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (head+end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;元素&quot;</span> + target + <span class="string">&quot;找到了,索引位置在&quot;</span> + mid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr2[mid] )</span><br><span class="line">            &#123;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr2[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                head = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head&gt; end) System.out.println(<span class="string">&quot;没有找到此元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二维数组</title>
      <link href="/2023/09/11/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2023/09/11/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><ul><li>对于二维数组的理解,可以看成是一维数组array1又作为另一个一位数组array2的元素而存在</li><li>其实,从数组底层的运行机制来看,其实没有多维数组</li><li>概念:数组的外层元素,数组的内层元素</li><li>外层元素:默认存储地址值</li><li>内层:默认与一维数组元素的不同类型的默认值规定相同</li></ul><hr><h1 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h1><ul><li>数组的声明和初始化</li><li>调用数组的指定元素</li><li>数组的属性:length,表示数组的长度</li><li>数组的遍历</li><li>数组元素的默认初始化值</li><li>二维数组的内存解析</li></ul><p>方式1:静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>方式2:动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr2 =<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>方式3:动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[][] arr3 =<span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure><p>举例:具体二维数组的代码的内存解析</p><ul><li><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.PNG" alt="Alt text"></li><li><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%901.PNG" alt="Alt text"></li><li><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%841.PNG" alt="Alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/09/11/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/09/11/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数组的概念"><a href="#一维数组的概念" class="headerlink" title="一维数组的概念"></a>一维数组的概念</h1><p>数组(Array),是多个相同类型数据按一定顺序排列的集合,并使用一个名字命名,并通过编号的方式对这些数据进行统一管理<br>数组中的概念</p><ul><li>数组名</li><li>下标(或索引)</li><li>元素</li><li>数组的长度</li></ul><h1 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h1><ul><li>数组本身是<strong>引用数据类型</strong>,而数组中的元素可以是<strong>任何数据类型</strong>,包括基本数据类型和引用数据类型</li><li>创建数组对象会在内存中开辟一整块<strong>连续的空间</strong>,占据的空间的大小,取决于数组的长度和数组中元素的类型</li><li>数组中的元素在内存中是依次紧密排列的,有序的</li><li>数组,一旦初始化完成,其长度就是确定的,数组的<strong>长度一旦确定,就不能修改</strong></li><li>我们可以直接通过下标(或索引)的方式调用指定位置的元素,速度很快</li><li>数组名引用的是这块连续空间的首地址</li></ul><p>数组的声明和初始化</p><ul><li>数据类型 变量名 &#x3D; 变量值</li></ul><p>方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] prices;</span><br><span class="line">      prices=<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">20.32</span>,<span class="number">43.21</span>,<span class="number">43.22</span>&#125;;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] foods=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>举例:具体一维数组的代码的内存解析</p><ul><li><img src="/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.PNG" alt="Alt text"></li><li><img src="/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%901.PNG" alt="Alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谷粒记账系统</title>
      <link href="/2023/09/09/%E8%B0%B7%E7%B2%92%E8%AE%B0%E8%B4%A6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/09/%E8%B0%B7%E7%B2%92%E8%AE%B0%E8%B4%A6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="谷粒记账系统"><a href="#谷粒记账系统" class="headerlink" title="谷粒记账系统"></a>谷粒记账系统</h1><ul><li>模拟实现基于文本界面的《谷粒记账软件》</li><li>该软件能够记录家庭的收入,支出,并能够打印收支明细表</li><li>项目采用分级菜单方式,主菜单如下</li></ul><hr><pre><code>        谷粒记账软件                     1.收支明细        2.登记收入        3.登记支出        4.退出        请选择(1-4):</code></pre><p>需求说明:</p><ul><li>假设家庭起始的生活基本金为10000元</li><li>每次登记收入(菜单2)后,收入的金额应累加到基本金上,并记录本次收入明细,以便后续的查询</li><li>每次等级支出(菜单3)后,支出的金额应从基本金扣除,并记录本次支出明细,以便后续的查询</li><li>查询收支明细(菜单1)时,将显示所有的收入,支出明细列表</li></ul><p>主方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuLiAccount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">10000</span>;<span class="comment">//初始金额</span></span><br><span class="line">        String info=<span class="string">&quot;&quot;</span>;<span class="comment">//记录收支的信息</span></span><br><span class="line">        <span class="comment">//记录收支的信息StringBuilder info= new StringBuilder();</span></span><br><span class="line">        <span class="keyword">while</span> (isFlag)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------谷粒记账软件-------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;              1.收支明细             &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;              2.登记收入             &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;              3.登记支出             &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;              4.退   出             &quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;              请选择(1-4):&quot;</span>);</span><br><span class="line">        <span class="type">char</span> selection=Utility.readMenuSelection();<span class="comment">//获取用户选择:&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3,&#x27;,&#x27;4&#x27;</span></span><br><span class="line">        <span class="keyword">switch</span> (selection)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;------------当前收支明细记录------------&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;收支\t\t账户金额\t\t收支金额\t\t说   明&quot;</span>);</span><br><span class="line">                System.out.println(info);</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                System.out.print(<span class="string">&quot;本次收入金额: &quot;</span>);</span><br><span class="line">                <span class="type">int</span> money=Utility.readNumber();</span><br><span class="line">                <span class="keyword">if</span> (money&gt;<span class="number">0</span>)balance+=money;</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入收入说明: &quot;</span>);</span><br><span class="line">                String addDesc=Utility.readString();</span><br><span class="line">                <span class="comment">//info.append(&quot;收入\t&quot;).append(balance).append(&#x27;\t&#x27;).append(&#x27;\t&#x27;).append(money).append(&#x27;\t&#x27;).append(&#x27;\t&#x27;).append(addDesc).append(&#x27;\n&#x27;);</span></span><br><span class="line">                <span class="comment">//记录收支的信息</span></span><br><span class="line">                info +=<span class="string">&quot;收入\t\t&quot;</span>+balance+ <span class="string">&quot;\t\t&quot;</span> +money+<span class="string">&quot;\t\t\t&quot;</span>+addDesc+<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------------------登记完成-------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                System.out.print(<span class="string">&quot;本次消费金额: &quot;</span>);</span><br><span class="line">                <span class="type">int</span> money1=Utility.readNumber();</span><br><span class="line">                <span class="keyword">if</span> (money1&gt;<span class="number">0</span> &amp;&amp; money1&lt;=balance)</span><br><span class="line">                    balance-=money1;</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入消费说明:&quot;</span>);</span><br><span class="line">                String addDesc1=Utility.readString();</span><br><span class="line">                <span class="comment">//info.append(&quot;消费\t&quot;).append(balance).append(&quot;\t&quot;).append(&#x27;\t&#x27;).append(money1).append(&quot;\t&quot;).append(&#x27;\t&#x27;).append(addDesc1).append(&quot;\n&quot;);</span></span><br><span class="line">                <span class="comment">//记录收支的信息</span></span><br><span class="line">                info +=<span class="string">&quot;消费\t\t&quot;</span>+balance+ <span class="string">&quot;\t\t&quot;</span> +money1+<span class="string">&quot;\t\t\t&quot;</span>+addDesc1+<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------------------登记完成-------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;\n确认是否退出(Y/N):&quot;</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">isExit</span> <span class="operator">=</span> Utility.readConfirmSelection();</span><br><span class="line">                <span class="keyword">if</span> (isExit == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    isFlag= <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用方法实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Utility工具类：</span></span><br><span class="line"><span class="comment"> 将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readMenuSelection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>);</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;1&#x27;</span> &amp;&amp; c != <span class="string">&#x27;2&#x27;</span> &amp;&amp; c != <span class="string">&#x27;3&#x27;</span> &amp;&amp; c != <span class="string">&#x27;4&#x27;</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;选择错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     用于收入和支出金额的输入。该方法从键盘读取一个不超过4位长度的整数，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;数字输入错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     用于收入和支出说明的输入。该方法从键盘读取一个不超过8位长度的字符串，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readConfirmSelection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>).toUpperCase();</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span> || c == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;选择错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readKeyBoard</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            line = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (line.length() &lt; <span class="number">1</span> || line.length() &gt; limit) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;输入长度（不大于&quot;</span> + limit + <span class="string">&quot;）错误，请重新输入：&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/images/%E8%B0%B7%E7%B2%92.PNG" alt="Alt text"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For循环</title>
      <link href="/2023/09/08/for%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/09/08/for%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h1><ol><li>Java中规范了3中循环结构:for,while,do-while</li><li>凡是循环结构,就一定会有4个要素</li></ol><ul><li>1.初始化条件</li><li>2.循环条件—&gt;一定是boolean类型的变量或表达</li><li>3.循环体</li><li>4.迭代部分(更新部分)</li></ul><ol start="3"><li>for循环的格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>案例一:<strong>水仙花数</strong><br>解析:输出所有的水仙花数,所谓水仙花数是指一个3位数,其各个位上数字立方和等于其本身<br>例如: 153&#x3D;1^1^1+3^3^3+5^5^5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Narcissistic_Number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">100</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="type">int</span> bai=i/<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> shi=i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> ge=i%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> sum=bai*bai*bai+shi*shi*shi+ge*ge*ge;</span><br><span class="line">        <span class="keyword">if</span>(i==sum)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二:<strong>最大公约数和最小公倍数</strong><br>解析:案例:输入两个正整数m和n,求其最大公约数和最小公倍数<br>比如:12和20的最大公约数是4,最小公倍数是60</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Greatest_Common_Divisor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">18</span>;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">24</span>;</span><br><span class="line">        <span class="type">int</span> min= (m &lt; n)?m :n;</span><br><span class="line">        <span class="type">int</span> max=(m &gt; n)?m : n;</span><br><span class="line">        <span class="comment">//最大公约数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=min;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m%i==<span class="number">0</span>&amp;&amp;n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小公倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=max;i&lt;=m*n;i++</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%m==<span class="number">0</span>&amp;&amp;i%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例三:<strong>猜数游戏</strong><br>随机生成一个100以内的数,猜这个随机数是多少?<br>解析:从键盘输入数,如果大了,提示大了,如果小了,提示小了,如果对了,就不再猜了,并统计一共猜了多少次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Guess_Game</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> random=(<span class="type">int</span>)(Math.random()*<span class="number">101</span>)+<span class="number">1</span>;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(random);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你要猜的整数:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> guess=scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (guess!=random)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess&gt;random)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜大了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;猜小了&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入你要猜的整数:&quot;</span>);</span><br><span class="line">            guess=scanner.nextInt();</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜你猜对了,你一共猜了&quot;</span>+sum+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例四:<br>世界最高山峰是珠穆朗玛峰,它的高度是8848.86米,假如我有一张足够大的纸,它的厚度是0.1毫米,<br>请问,我折叠多少次,可以折成珠穆朗玛峰的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Paper_Folding</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> paper=<span class="number">0.1</span>;<span class="comment">//单位：毫米</span></span><br><span class="line">        <span class="type">double</span> zf=<span class="number">8848860</span>;<span class="comment">//单位：毫米</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (paper&lt;=zf)</span><br><span class="line">        &#123;</span><br><span class="line">            paper*=<span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;一共折叠了&quot;</span>+count+<span class="string">&quot;次&quot;</span>+<span class="string">&quot;当前纸的高度为&quot;</span>+ (paper/<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例五:题目:模拟ATM取款</p><p>声明变量balance并初始化为0,用以表示银行账户的余额,下面通过ATM机程序实现存款,取款等功能<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ATM&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>       1.存款<br>       2.取款<br>       3.显示余额<br>       4.退出<br>请选择(1-4):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> balance=<span class="number">0.0</span>;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===========ATM===============&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;       1.存款         &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;       2.取款         &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;       3.显示余额      &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;       4.退出         &quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请选择(1-4):&quot;</span>);</span><br><span class="line">            <span class="type">int</span> number=scan.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (number)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要存的金额:&quot;</span>);</span><br><span class="line">                    <span class="type">double</span> money1=scan.nextDouble();</span><br><span class="line">                    <span class="keyword">if</span> (money1&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        balance+=money1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;------存款成功------&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要取的金额:&quot;</span>);</span><br><span class="line">                    <span class="type">double</span> money2=scan.nextDouble();</span><br><span class="line">                    <span class="keyword">if</span> (money2&gt;<span class="number">0</span> &amp;&amp; balance&gt;=money2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        balance-=money2;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;------取款成功------&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;你的余额为&quot;</span>+balance);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢使用,欢迎下次光临&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;------输入错误,请重新输入------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>For循环嵌套的使用</title>
      <link href="/2023/09/08/for%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/09/08/for%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="循环嵌套的使用"><a href="#循环嵌套的使用" class="headerlink" title="循环嵌套的使用"></a>循环嵌套的使用</h1><ol><li><p>嵌套循环:是指一个循环结构A的循环体是另一个循环结构B</p><ul><li>外层循环:循环结构A</li><li>内层循环:循环结构B</li></ul></li><li><p>说明:</p><ul><li>内层循环充当了外层循环的循环体</li><li>对于两层嵌套循环来说,外层循环控制行数,内层循坏控制列数</li><li>举例:外层循环执行m次,内层循环执行n次,则内层循环的循环体共执行 m * n次</li></ul></li></ol><ul><li><p>案例一 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出运行结果:</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">liu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j%<span class="number">6</span>==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>案例二:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">****</span></span><br><span class="line"><span class="comment">*****</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">liu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例三:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">*****</span></span><br><span class="line"><span class="comment">****</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">liu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">6</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例四:<br>编写出一个以星号的菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">      * * *</span></span><br><span class="line"><span class="comment">    * * * * *</span></span><br><span class="line"><span class="comment">  * * * * * * *</span></span><br><span class="line"><span class="comment">* * * * * * * * *</span></span><br><span class="line"><span class="comment">  * * * * * * *</span></span><br><span class="line"><span class="comment">    * * * * *</span></span><br><span class="line"><span class="comment">      * * *</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">liu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>-<span class="number">2</span>*i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>*i-<span class="number">1</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">9</span>-<span class="number">2</span>*i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例五:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印一个九九乘法表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Table</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.print( j + <span class="string">&quot; * &quot;</span> + i + <span class="string">&quot; = &quot;</span> + i * j +<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例六:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目:找出100以内所有的素数(质数)? 100000以内呢</span></span><br><span class="line"><span class="comment">质数:只能被1和它本身整除的自然数,比如2,3,5,7,11,13.....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime_Number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//bolean flag=true;</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (flag) System.out.println(i);</span><br><span class="line">         flag=<span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例七：性能测试,不同算法的优化后得到极大的提升</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历100000以内的所有的质数,体会不同的算法实现,其性能的差别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime_Number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> start=System.currentTimeMillis();<span class="comment">//获取系统当前的时间</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录质数的个数</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//bolean flag=true;</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;=Math.sqrt(i);j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//针对对非质数有关系</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (flag) count++;</span><br><span class="line">         flag=<span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">long</span> end=System.currentTimeMillis();<span class="comment">//获取系统当前的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;质数的总个数为:&quot;</span>+count);<span class="comment">//9592个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为:&quot;</span>+(end - start));</span><br><span class="line">        <span class="comment">//[11204mm]----&gt;加上break后[1068mm]----&gt;加上Math.sqrt()函数后[11mm]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Switch-case</title>
      <link href="/2023/09/08/switch-case/"/>
      <url>/2023/09/08/switch-case/</url>
      
        <content type="html"><![CDATA[<h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h1><ol><li>语法格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">    <span class="comment">//执行语句1</span></span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//执行语句2</span></span><br><span class="line">    <span class="comment">//break;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//执行语句3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行过程:<br>根据表达式中的值,依次匹配case语句,一旦与某一个case中的常量相等,那么就执行此case中的执行语句,执行完此执行语句之后:</li></ol><ul><li>情况1:遇到break,则执行break后,跳出当前的Switch-case结构</li><li>情况2:没有遇到break,则继续执行其后的case中的执行语句</li></ul><p> 3. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例:编写程序,从键盘上输入2023年 &quot;month&quot; 和 &quot;day&quot;,要求通过程序输出输入的日期为2023年的第几天</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">package</span> javaSE_chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">number_of_days</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第几月:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> month=scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第几天:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> day=scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> sumDays=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (month)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                sumDays +=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sumDays +=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                sumDays +=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                sumDays +=<span class="number">28</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                sumDays +=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                sumDays +=day;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                sumDays +=day;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误,月份区间为[1-12],天数区间为[0,31]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(month+<span class="string">&quot;月&quot;</span>+day+<span class="string">&quot;天&quot;</span>+<span class="string">&quot;是365天中的第&quot;</span>+sumDays+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Scanner类的输入</title>
      <link href="/2023/09/08/Scanner%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/09/08/Scanner%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><ol><li>步骤一:导包</li></ol><ul><li>import java.util.Scanner;</li></ul><ol start="2"><li><p>步骤二:提供或者创建一个Scanner类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">(变量类型 变量名 = 变量值)</span><br></pre></td></tr></table></figure></li><li><p>步骤三:调用Scanner类中的方法,获取指定类型的变量</p></li></ol><ul><li>字符型:String hanson&#x3D;scanner.next();  </li><li>数值型:double height &#x3D; scanner.nextDouble();</li><li>布尔型:boolean hanson &#x3D; scanner.nextBoolean();</li><li>整型:int pretty&#x3D;scanner.nextInt();</li></ul><ol start="4"><li>步骤四:关闭资源,调用scanner类的close()</li></ol><ul><li>scanner.close();</li></ul><p>例题：大家都知道,男大当婚,女大当嫁,那么女方家长要嫁女儿,当然要提出一定的条件,身高:180cm以上,富:财富1千万以上,帅:是<br>1.如果这三个条件同时满足,则:”我一定要嫁给他！！！”<br>2.如果三个条件有为真的情况,则:”嫁吧,比上不足,比下有余。”<br>3.如果三个条件都不满足,则:”不嫁”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">yu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的身高(cm):&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;你的资产多少(千万为单位):&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">property</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;你帅吗(是:true\\否:false):&quot;);</span></span><br><span class="line">        <span class="comment">//boolean hanson = scanner.nextBoolean();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你帅吗(帅/不帅):&quot;</span>);</span><br><span class="line">        String hanson=scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;你的身高是&quot;</span> + height + <span class="string">&quot;，你的资产是&quot;</span> + property + <span class="string">&quot;千万，你很帅：&quot;</span> + hanson);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;请确认你输入的是否属实(是:true\\否:false):&quot;);</span></span><br><span class="line">        <span class="comment">//boolean enter = scanner.nextBoolean();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请确认你输入的是否属实(是/否):&quot;</span>);</span><br><span class="line">        String enter=scanner.next();</span><br><span class="line">        <span class="keyword">if</span> (enter.equals(<span class="string">&quot;是&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height &gt; <span class="number">180</span> &amp;&amp; property &gt; <span class="number">1</span> &amp;&amp; hanson.equals(<span class="string">&quot;帅&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我一定要嫁给你!!!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height &gt; <span class="number">188</span> || property &gt; <span class="number">1</span> || hanson.equals(<span class="string">&quot;帅&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;嫁，比上不足比下有余&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> System.out.println(<span class="string">&quot;不嫁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句</title>
      <link href="/2023/09/07/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/09/07/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><p>概念：是用来控制程序中各<strong>语句执行顺序</strong>的语句,可以把语句组合成能完成一定功能的小逻辑模块</p><p>程序设计中规定的三中流程结构:</p><ul><li><p><strong>顺序结构</strong></p><ul><li>程序从上到下逐行地执行,中间没有任何判断和跳转</li></ul></li><li><p>*<strong>分支结构</strong></p><ul><li>根据条件,选择性地执行某段代码</li><li>有if…else和switch-case两种分支语句</li></ul></li><li><p><strong>循环结构</strong></p><ul><li>根据循环条件,重复性的执行某段代码</li><li>有for while do-while三种循环语句</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序进程线程</title>
      <link href="/2023/09/07/%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/09/07/%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>指：为完成特定任务,用某种语言编写的一组指令的集合,即指一段静态的代码</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>指：程序的一次执行过程,程序是静态的,进程是动态的</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>指：进程可进一步细化为线程,是程序内部的一条执行路径  </p><h3 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h3><ol><li>提高应用程序的响应,对图形化界面更有意义,可增强用户体验</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构,将复杂的进程分为多个线程,独立运行,利于理解和修改</li></ol><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p>并行：指两个或多个事件在<strong>同一时刻</strong>发生,有<strong>多条指令</strong>在多个cpu上同时执行 </p></li><li><p>并发：指两个或多个事件在<strong>同一个时间段内</strong>发生,有<strong>多条指令</strong>在<strong>单个CPU</strong>上<strong>快速轮换,交替</strong>执行</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试真题</title>
      <link href="/2023/09/07/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/09/07/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h1><ol><li><p>高效的方式计算2*8的值<br> 答：2 &lt;&lt; 3  </p></li><li><p>&amp;和&amp;&amp;的区别</p></li></ol><ul><li>答：不同点:当&amp;两边的数值时,左边为假,右边继续执行,当&amp;&amp;两边的数值时,左边为假,右边就不在执行</li><li>答：相同点:都是且的关系,两边都是条件为真的都执行</li></ul><ol start="3"><li>Java中的基本类型有哪些?String时最基本的数据类型吗?</li></ol><ul><li>答：8种基本数据类型,</li><li>算术运算符</li><li>关系运算符</li><li>条件运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>位运算符</li><li>Lambda运算符<br>  String不是基本数据类型,是引用数据类型</li></ul><ol start="4"><li>Java开发中计算金额时使用什么数据类型?</li></ol><ul><li>答:不能使用Float或者Double,因为精度不高,使用BigDecimal类替换,可以实现任意精度的数据的运算</li></ul><ol start="5"><li>char型变量中能不能存储一个中文汉字,为什么?</li></ol><ul><li>答:可以的,char c1&#x3D;’中’,char c2&#x3D;’a’,因为char使用的是Unicode字符集,包含了世界范围的所有的字符</li></ul><ol start="6"><li>Boolean 占几个字节?</li></ol><ul><li>编译时不谈占几个字节,但是JVM在给boolean类型分配内存空间时,boolean类型的变量占据一个槽位（slot,等于4个字节）<br>  细节:true:1 false:0</li><li><blockquote><p>拓展:在内存中,byte\short\char\boolean\int\float:占用1个slot（一个slot&#x3D;4个字节）<br>  double\long:占用2个slot（2个slot&#x3D;8个字节）</p></blockquote></li></ul><ol start="7"><li>为什么Java中0.1+0.2结果不是0.3?注：在代码中测试0.1+0.2,你会惊讶的发现,结果不是0.3,而是0.3000…..4,这是为什么?</li></ol><ul><li>答:几乎所有现代的编程语言都会遇到上述问题,包括JavaScript,Ruby,Python，Swift和Go,引发这个问题的原因是,它们都采用了<em><strong>IEEE 754</strong></em>标准</li><li><blockquote><p>IEEE是指”电气与电子工程师协会” 根据这个标准,小数的二进制表达能够有最大的精度上限提升,但无论如何,仍然不能实现每一个十进制小数,都对应一个二进制小数,正因如此,产生了0.1+0.2不等于0.3的问题</p></blockquote></li></ul><ol start="8"><li>if分支语句和switch分支语句的异同之处?</li></ol><ul><li>if-else语句优势<ul><li>if语句的条件是一个布尔类型值,if条件表达式为true则进入分支,可以用于范围的判断,也可以用于等值的判断,<strong>使用范围更广</strong></li><li>switch语句的条件是一个常量值(byte,short,int,char,枚举,String),只能判断某个变量或表达式的结果是否等于某个常量值,<strong>使用场景较狭窄</strong></li></ul></li><li>switch语句优势<ul><li>当条件是判断某个变量或者表达式是否等于某个固定的常量值时,使用if和switch都可以,习惯上使用switch更多,因为<strong>效率稍高</strong>,当条件是区间范围的判断时,只能使用if语句</li><li>使用switch可以利用<strong>穿透性</strong>,同时执行多个分支,而if…else没有穿透性</li></ul></li></ul><ol start="9"><li>Java中的内存结构是如何划分的?(主要关心JVM运行时内存环境)</li></ol><ul><li>将内存区域分为5个部分:程序计数器,虚拟机栈,本地方法栈,堆,方法区</li><li><blockquote><p>内存结构:比如int[] arr &#x3D; new int[]{1,2,3};<br>  虚拟机栈:用于存放方法中声明的变量。比如:arr<br>  堆:用于存放数组的实体(即数组中所有的元素)比如:{1,2,3}</p></blockquote></li></ul><ol start="10"><li>举例:具体一维数组的代码的内存解析</li></ol><ul><li><img src="/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.PNG" alt="Alt text"></li><li><img src="/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%901.PNG" alt="Alt text"></li></ul><ol start="11"><li>数组的使用中常见的异常小结</li></ol><ul><li>数组下标越界的异常:ArrayIndexOutOfBoundsException</li><li>空指针的异常:NullPointerException</li></ul><ol start="12"><li>出现异常会怎样?如何处理?</li></ol><ul><li>一旦程序执行中出现了异常,程序就会终止执行</li><li>针对异常提供的信息,修改对应的代码,避免异常再次出现</li></ul><ol start="13"><li>数组有没有length()这个方法?String有没有length()这个方法?</li></ol><ul><li>数组没有length(),是length属性</li><li>string有这个length()方法</li></ul><ol start="14"><li>有数组int[] arr,用java代码将数组元素顺序颠倒?</li></ol><ul><li>使用反转代码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">78</span>,<span class="number">69</span>,<span class="number">85</span>,<span class="number">58</span>,<span class="number">77</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">91</span>,<span class="number">24</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;arr.length; j++) &#123;</span><br><span class="line">        System.out.print(arr[j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp=arr[i];</span><br><span class="line">        arr[i]=arr[arr.length - <span class="number">1</span> - i];</span><br><span class="line">        arr[arr.length - <span class="number">1</span> - i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;arr.length; j++) &#123;</span><br><span class="line">        System.out.print(arr[j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li>为什么数组要从0开始编号,而不是1？</li></ol><ul><li>数组的索引,表示了数组元素距离首地址的偏离量,因为第1个元素的地址与首地址相同,所以偏移量就是0,所以从0开始</li></ul><ol start="16"><li>重载:如何判断两个方法是相同的呢?</li></ol><ul><li>方法名相同,且形参列表相同(形参列表相同指的是参数个数和类型都相同,与形参名没关系)</li><li>在一个类中允许存在多个相同名字的方法,只要他们的形参列表不同即可</li></ul><ol start="17"><li>请说出三个运行结果?</li></ol><ul><li><img src="/images/%E9%9D%A2%E8%AF%95.PNG" alt="Alt text"></li></ul><ol start="18"><li>java中的参数传递机制是什么?</li></ol><ul><li>值传递（不是引用传递）</li></ul><ol start="19"><li>面向对象,面向过程的理解?</li></ol><ul><li>不管是面向过程,面向对象,都是程序设计的思路</li><li>面向过程:以函数为基本单位,适合解决简单问题,如：开车</li><li>面向对象:以类为基本单位,适合解决复杂问题,如：造车</li></ul><ol start="20"><li>Java的引用类型有几种?</li></ol><ul><li>类,数组,接口,枚举,注解,记录</li></ul><ol start="21"><li>类和对象的区别?</li></ol><ul><li>类:抽象的,概念上的定义</li><li>对象:具体的,类的一个一个的实例</li></ul><ol start="22"><li>面向对象,项目中哪些地方用到面向对象?</li></ol><ul><li>万事万物皆对象</li><li>不管是app开发过程中,都必须有对象进行实例化,再利用面向对象中的三大特征,封装、继承、多态来进行操作对象以完成相应的功能</li></ul><ol start="23"><li>java虚拟机中内存划分为哪些区域,详细介绍一下？</li></ol><ul><li>内存划分区域:<strong>虚拟机栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、程序计数器、本地方法栈</li></ul><ol start="24"><li>对象存在Java内存的哪块区域里面?</li></ol><ul><li>堆空间</li></ul><ol start="25"><li>private,缺省,protected,public的表格化作用区域？</li></ol><ul><li><img src="/images/%E4%BF%AE%E9%A5%B0%E7%AC%A6.PNG" alt="Alt text"></li></ul><ol start="26"><li>main方法的public能不能换成private?为什么?</li></ol><ul><li>能,但是改以后就不能作为程序的入口,就只是一个普通的方法</li></ul><ol start="27"><li>构造方法和普通方法的区别？</li></ol><ul><li>编写代码的角度:没有共同点,声明格式,作用都不同</li><li>字节码文件的角度:构造器会以init()方法形态呈现,用以初始化对象</li></ul><ol start="28"><li>成员变量和局部变量的区别?</li></ol><ul><li>声明的位置</li><li>内存中存放的位置</li><li>作用域</li><li>权限修饰符</li><li>初始化值</li><li>生命周期</li></ul><ol start="29"><li>变量赋值和构造方法加载的优先级问题?</li></ol><ul><li>变量显示赋值先于构造器中的赋值</li><li>看的字节码文件</li></ul><ol start="30"><li>final、finally、finalize的区别？</li></ol><ul><li><strong>final</strong>:关键字,如果一个类被声明为final,不能再派生新的子类，不能作为父类被继承。<br>  将变量或方法声明为final,可以保证他们使用中不被改变。被声明为final的变量必须在声明时给定初值，而以后的引用中只能读取，不可修改，被声明为final的方法也同样只能使用，不能重载。</li><li><strong>finally</strong>: 关键字,在异常处理时提供finally块来执行操作。如果抛出一个异常，那么相匹配的catch语句就会执行，然后控制就会进入finally块，</li><li><strong>finalize</strong>: 方法名,java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。(指临死前说的遗言)</li></ul><ol start="31"><li>&#x3D;&#x3D;和equals()方法的区别</li></ol><ul><li>&#x3D;&#x3D;的用法<ol><li>&#x3D;&#x3D;是运算符,如果是基本数据类型,则比较存储的值</li><li>&#x3D;&#x3D;是引用数据类型,则比较所指向对象的地址值</li></ol></li><li>equals()的用法<ol><li>equals()是Object的方法,比较的是所指向的对象的地址值,一般情况下,重写之后比较的是对象的值。</li></ol></li></ul><ol start="32"><li>静态变量和实例变量的区别?</li></ol><ul><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul><ol start="33"><li>静态属性和静态方法是否可以被继承?是否可以被重写,以及原因？</li></ol><ul><li>可以继承,静态方法不能被重写,不存在多态性,不能重载</li></ul><ol start="34"><li>是否可以从一个static方法内部发出对非static方法的调用</li></ol><ul><li>只能通过对象来对非静态方法的调用</li></ul><ol start="35"><li>被static 修饰的成员(类,方法,成员变量)能否再使用private进行修饰？</li></ol><ul><li>可以,除了代码块</li></ul><ol start="36"><li>main()方法中是否可以将public改成private</li></ol><ul><li>可以,改完不是程序入口</li></ul><ol start="37"><li>三个类的对比:String、StringBuffer、StringBuilder</li></ol><ul><li>String：不可变字符序列,底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li><li>StringBuffer：可变字符序列；JDK1.0声明,线程安全的,效率低，底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li><li>StringBuilder：可变字符序列,JDK5.0声明,线程不安全的,效率高，底层使用char<a href="jdk8%E5%8F%8A%E4%B9%8B%E5%89%8D"></a>，底层使用byte[]，(jdk9及之后)</li></ul><ol start="38"><li>以下两种方式创建的String对象有什么不同?<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> String str= <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第一种是创建了两个对象,一个是放在字符串常量池里面,一个是放在堆空间创建</p></li><li><p>第二种创建了一个对象,直接声明在字符串常量池里面</p></li></ul><ol start="39"><li>String a &#x3D;”abc”，String b  &#x3D; “a” + “bc”,问a &#x3D;&#x3D; b?</li></ol><ul><li>相等,因为这是一个常量 + 常量的运算</li></ul><ol start="40"><li>String中的 “+” 怎样实现？</li></ol><ul><li>常量 + 常量：是相等的</li><li>常量 + 变量：创建一个StringBuilder的实例,通过append()添加字符串,最后调用toString()返回一个字符串,（toString()内部是new一个String的实例）</li><li>变量 + 变量：创建一个StringBuilder的实例,通过append()添加字符串,最后调用toString()返回一个字符串,（toString()内部是new一个String的实例）</li></ul><ol start="41"><li>Java中String是不是final的?</li></ol><ul><li>是final的，也表明了不能被继承</li></ul><ol start="42"><li>List:存储有序,可重复的数据,说一下List的子类ArrayList和Vector的区别？</li></ol><ul><li><img src="/images/list.PNG" alt="Alt text"></li></ul><ol start="43"><li>区分 Collection 和 Collections 的区别</li></ol><ul><li><p>Collection：集合框架中的用于存储一个一个元素的接口,又分为List和Set等子接口</p></li><li><p>Collections：用于操作集合框架的一个工具类,此时的集合框架包括,Set、List、Map</p></li></ul><ol start="44"><li>Java的泛型是什么？有什么好处和优点？JDK不同版本的泛型有什么区别？</li></ol><ul><li>泛型，是程序中出现的不确定的类型<br>以集合来举例：把一个集合中的内容限制为一个特定的数据类型，这就是泛型背后的核心思想  </li><li>好处：内容限制为一个特定的数据类型  </li><li>jdk7.0新特性<ul><li>类型推断,前面写了泛型类型，后面不用写</li></ul></li></ul><ol start="45"><li>链表和数组有什么区别？</li></ol><ul><li>数组是开辟一整块连续的空间</li><li>链表是物理逻辑上看似连续的空间,实则是通过链表的方式存储的</li></ul><ol start="46"><li>Java中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别哪些类？</li></ol><ul><li>InputStream\OutputStream\Reader\Writer</li></ul><ol start="47"><li>流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？</li></ol><ul><li>需要。close()</li><li>处理流在关闭过程中,也会关闭内部的流</li></ul><ol start="48"><li>OutputStream里面的write()是什么意思?</li></ol><ul><li>数据写出的意思,默认是8kb</li></ul><ol start="49"><li>BufferedReader属于哪种流？他主要是用来做什么的？</li></ol><ul><li>输入流,字符流，处理流</li><li>主要用来当一个文件较大的时候，用来读取数据</li></ul><ol start="50"><li>什么是缓冲区？有什么作用？</li></ol><ul><li>内部提供了一个数组，将读取或要写出的数据，先在此数组中缓存。达到一定程度时，集中性的写出。</li><li>作用：减少与磁盘的交互，进而提升读写效率</li></ul><ol start="51"><li>什么是Java序列化，如何实现</li></ol><ul><li>序列化过程：对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上或通过网络将这种二进制流传输到另一个网络节点。</li><li>反序列化过程：当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li></ul><ol start="52"><li>Java有些类中为什么需要实现Serializable接口？</li></ol><ul><li>便于此类的对象实现序列化操作</li></ul><ol start="53"><li>反射的优缺点？<br>优点：</li></ol><ul><li>提高了Java程序的灵活性和扩展性，降低了耦合性，提高自适应能力</li><li>允许程序创建和控制任何类的对象，无需提前硬编码目标类</li></ul><p>缺点： </p><ul><li>反射的性能较低</li><li>反射会模糊程序内部逻辑，可读性较差</li><li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li></ul><ol start="54"><li>.Class类的作用？生成Class对象的方法有哪些？</li></ol><ul><li>反射的源头。</li><li>主要有三种。</li></ul><ol start="55"><li>Class.forName(“全路径”)会调用哪些方法？会调用构造方法吗？加载的类会放在哪？</li></ol><ul><li>Class.forName0会执行执行类构造器<c1init>0方法</li><li>不会调用构造方法</li><li>加载的类放在方法区</li></ul><ol start="56"><li>说一下创建对象的几种方法？</li></ol><ul><li>new 方式</li><li>静态方法</li><li>Builder&#x2F;Factory的静态方法</li><li>反射的newInstance()</li><li>clone()方法</li><li>反序列化</li></ul><ol start="57"><li>如何找到对象实际类</li></ol><ul><li>对象.getClass();</li></ul><ol start="58"><li>Java反射创建对象效率高还是通过new创建对象的效率高？</li></ol><ul><li>new的方式</li></ul><ol start="58"><li><p>如何利用反射机制来访问一个类的方法？</p></li><li><p>通过cLass的实例调用getDeclaredMethod(StringmethodName，CLass…args)，获取指定的方法</p></li><li><p>setAccessible（true）：确保此方法是可访问的</p></li><li><p>通过Method实例调用invoke（objectobj，Object…objs），即为对Method对应的方法的调用,</p><ul><li>invoke()的返回值即为Method对应的方法的返回值</li><li>特别的，如果Method对应的方法的返回值类型为void，则invoke）返回值为nuLl</li></ul></li><li><p>说一下java反射获取私有属性,如何改变值？</p></li><li><p>通过cLass实例调用getDeclaredField（StringfieldName），获取运行时类指定名的属性</p></li><li><p>setAccessible(true)：确保此属性是可以访问的</p></li><li><p>通过Filed类的实例调用get（objectobj）（获取的操作）或set（objectobjObjectvalue设置的操作）进行操作。</p></li></ol><ul><li>注意！！！：针对于核心源码的api,内部的私 有的结构在jdk17中就不可以通过反射调用了</li></ul><ol start="60"><li><p>如何利用反射机制来访问一个类的构造器？</p></li><li><p>通过cLass的实例调用getDeclaredConstructor（cLass…args），获取指定参数类型的构造器</p></li><li><p>setAccessible（true）：确保此构造器是可以访问的</p></li><li><p>通过constructor实例调用newInstance（object…objs），返回一个运行时类的实例。</p></li><li><p>谈谈java8新特性</p></li></ol><ul><li>lambda表达式,Stream API</li><li>jdk的对比：元空间,HashMap，新的日期时间API，接口变化</li></ul><ol start="71"><li>JDK1.8在数据结构上发生了嘟些变化</li></ol><ul><li>使用元空间替代永久代。（方法区：jvm规范中提到的结构。</li><li>HotSpot来讲，jdk7：方法区的落地体现：永久代，jdk8：方法区的落地体现：元空间。</li><li>HashMap底层结构</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2023/09/07/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/09/07/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符是一种特殊的符号,用以表示数据的运算,赋值和比较等</p><p>运算符的分类:</p><ul><li>按照功能分为:算术运算符,赋值运算符,比较运算符,逻辑运算符,位运算符,条件运算符,Lambda运算符</li><li><img src="/images/%E8%BF%90%E7%AE%97%E7%AC%A61.PNG" alt="Alt text"></li></ul><p>算术运算符:</p><ul><li><img src="/images/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li></ul><p>赋值运算符:</p><ul><li><img src="/images/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li></ul><p>比较（关系）运算符:</p><ul><li><img src="/images/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li></ul><p>逻辑运算符:</p><ul><li><img src="/images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li></ul><p>位运算符:</p><ul><li><img src="/images/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li><li><blockquote><p>面试题:如果高效的方式计算2*8？<br> 2 &lt;&lt; 3 或者8 &gt;&gt; 1<br> 解释：2的二进制位 0000 0010,8的二进制位 0000 1000,当2左移3位时,移动的是二进制,变成 0001 0000 ，结果为16，同理8移动一位是一样的</p></blockquote></li></ul><p>条件运算符:</p><ul><li><img src="/images/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="Alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>随机数</title>
      <link href="/2023/09/07/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2023/09/07/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>如何获取随机数</p><ul><li>可以使用Java提供的API:Math类的random()</li><li>random()调用以后,会返回一个[0.0,1.0)范围的double型的随机数</li></ul><p>需求1:获取一个[0,100]范围的随机整数?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1=(<span class="type">int</span>)(Math.random()*<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line"> 注：[<span class="number">0.0</span>,<span class="number">1.0</span>)--&gt;[<span class="number">1</span>,<span class="number">101</span>)</span><br></pre></td></tr></table></figure><p>需求2:获取一个[1,100]范围的随机整数?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num2=(<span class="type">int</span>)(Math.random()*<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">注:[<span class="number">0.0</span>,<span class="number">1.0</span>)--&gt;[<span class="number">1</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure><blockquote><p>万能公式:获取一个[a,b]范围的随机整数?<br>int sum&#x3D;(int) (Math.random() * (b-a+1)) + a</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java第一章</title>
      <link href="/2023/09/06/%E5%8F%98%E9%87%8F/"/>
      <url>/2023/09/06/%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>变量的概念:<ul><li>内存中的一个存储区域,该区域的数据可以在同一类型范围内不断变化</li><li>变量的构成包含三个要素:数据类型,变量名,存储的值</li><li>Java中变量声明的格式:数据类型 变量名&#x3D;变量值</li></ul></li><li>变量的作用:用于在内存中保存数据</li><li>使用变量注意:<ul><li>Java中每个变量必须先声明,后使用</li><li>变量都有其作用域,变量只在作用域内是有效的,出了作用域就失效了</li><li>在同一个作用域内,不能声明两个同名的变量</li><li>定义好变量以后,就可以通过变量名的方式对变量进行调用和运算</li><li>变量值在赋值时,必须满足变量的数据类型,并且在数据类型有效的范围内变化</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java第一章</title>
      <link href="/2023/09/06/%E7%AC%AC%E4%B8%80%E7%AB%A0Java/"/>
      <url>/2023/09/06/%E7%AC%AC%E4%B8%80%E7%AB%A0Java/</url>
      
        <content type="html"><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>定义：被Java语言赋予了特殊含义，用做专门的字符串</li><li>特点：全部都是<strong>小写字母</strong></li><li>官方地址:  <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">关键字</a></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Java中变量,方法,类等要素命令时使用的字符序列,称为标识符。  </p><p>技巧:凡是自己可以取名字的地方都叫标识符。  </p><p><strong>标识符命名规则</strong></p><ul><li>由26个英文字母大小写,0-9,_或者$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字,但能包含关键字和保留字</li><li>java中严格区分大小写,长度无限制</li><li>标识符不能包含空格</li></ul><p><strong>标识符命令规范</strong></p><ul><li>包名:多单词组成所有字母都小写:xxxyyyzzz    </li><li>类名,接口名:多单词组成时,所有单词的首字母大写:XxxYyy</li><li>变量名,方法名:多单词组成时,第一个字母首字母小写,第二个单词开始每个单词首字母大写:xxxYyyZzz</li><li>常量名:所有字母都大写,多单词时每个单词用下划线连接:XXX_YYY_ZZZ</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程常用方法</title>
      <link href="/2023/09/06/%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/06/%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p>常用构造器</p><ul><li>public Thread()：分配一个新的线程对象</li><li>public Thread(String name):分配一个指定名字的新线程对象</li><li>public Thread(Runnable target):指定创建线程的目标对象,它实现了Runnable接口的run方法</li><li>public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字</li></ul><h3 id="线程常用方法-1"><a href="#线程常用方法-1" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><ul><li>start():启动线程和调用当前线程的run()</li><li>run()：声明run方法,执行</li><li>currentThread(): 获取当前执行代码对应的线程</li><li>getname():获取线程名</li><li>setname():设置线程名</li><li>sleep(long millis):静态方法,调用时,可以使得当前线程睡眠指定的毫秒数</li><li>yield():一但执行此方法,就释放CPU的执行权</li><li>join():在线程a中通过线程b调用join()，意味着线程a进入阻塞状态,直到线程b执行结束,线程a才结束阻塞状态,继续执行</li><li>isAlive():判断当前线程是否存活</li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>getPriority()：获取线程的优先级<br>setPriority()：设置线程的优先级 </p><p>Thread类内部声明的三个常量:</p><ul><li>MAX_PRIORITY(10),最高优先级</li><li>MIX_PRIORITY(1),最低优先级</li><li>NORM_PRIORITY(5),普通优先级,默认情况下main线程具有普通优先级</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>jdk1.5之前生命周期: <img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.PNG" alt="Alt text"> </p></li><li><p>jdk1.5之后生命周期: <img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.PNG" alt="Alt text"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java语言概述</title>
      <link href="/2023/09/05/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/05/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个HelloWorld"><a href="#第一个HelloWorld" class="headerlink" title="第一个HelloWorld"></a>第一个HelloWorld</h2><ul><li><img src="/images/%E6%A6%82%E8%BF%B03.PNG" alt="Alt text">   </li><li><img src="/images/%E6%A6%82%E8%BF%B04.PNG" alt="Alt text"></li><li><img src="/images/%E6%A6%82%E8%BF%B01.PNG" alt="Alt text"></li><li><img src="/images/%E6%A6%82%E8%BF%B02.PNG" alt="Alt text"></li></ul><h2 id="单行注释和多行注释"><a href="#单行注释和多行注释" class="headerlink" title="单行注释和多行注释"></a>单行注释和多行注释</h2><ul><li>单行注释 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//注释文字</span><br></pre></td></tr></table></figure> <img src="/images/%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A.PNG" alt="Alt text"></li><li>多行注释 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">注释文字1</span><br><span class="line">注释文字2</span><br><span class="line">注释文字3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure> <img src="/images/%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A.PNG" alt="Alt text"></li><li>文档注释(注解 Java特有)<br>说明：原有的注释功能里还能加上作者，版本号，电话，邮箱等并且显示出来，一般在代码结尾可以体现，<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">@author jie</span><br><span class="line">@version 1.0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><img src="/images/%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A.PNG" alt="Alt text"></li></ul><h1 id="java语言优缺点"><a href="#java语言优缺点" class="headerlink" title="java语言优缺点"></a>java语言优缺点</h1><p>优点</p><ol><li><strong>跨平台性</strong>:这是Java的核心优势,Java在最初设计就注重移植和跨平台性，通过Java语言编写的应用程序在不同的系统平台上都可以运行<br>  <img src="/images/%E4%BC%981.PNG" alt="Alt text"></li><li><strong>面向对象性</strong>:面向对象是一种程序设计技术,非常适合大型软件的设计和开发，面向对象编程支持封装,继承,多态等特性</li><li><strong>健壮性</strong>:吸收了C&#x2F;C++语言的优点,但去掉了影响程序健壮性的部分,提供了一个相对安全的内存管理和访问机制</li><li><strong>安全性高</strong>:Java适合于网络&#x2F;分布式环境，需要提供一个安全机制以防恶意代码的攻击</li><li><strong>简单性</strong>:Java就是c++语法的简化版</li><li><strong>高性能</strong>:Java语言本身发展中通过虚拟机的优化提升看十几倍运行效率</li><li>功能：<strong>自动内存管理(内存分配,内存回收)</strong><ul><li>Java程序在运行过程中,涉及到运算的数据的分配,存储都由JVM来完成。</li><li>java消除了程序员回收无用内存空间的职责,提供了一种系统跟踪存储空间的分配情况,在内存空间到达相应阈值时,检查并释放可以释放的内存</li><li>Gc的自动回收，提高了内存空间的利用效率,也提高了编程人员的效率，减少了没有释放空间而导致的内存泄漏</li></ul></li></ol><p>缺点</p><ul><li>语法过于复杂，成本较高</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK的选择和下载与安装</title>
      <link href="/2023/09/05/JDK/"/>
      <url>/2023/09/05/JDK/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="#JDK%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9">jdk版本选择</a></strong><br><strong><a href="#JDK%E7%9A%84%E4%B8%8B%E8%BD%BD">jdk下载</a></strong><br><strong><a href="#jdk%E7%9A%84%E5%AE%89%E8%A3%85">jdk的安装</a></strong><br><strong><a href="#%E9%85%8D%E7%BD%AEPath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">配置path环境变量</a></strong></p><h1 id="JDK的选择和下载"><a href="#JDK的选择和下载" class="headerlink" title="JDK的选择和下载"></a>JDK的选择和下载</h1><blockquote><p>jdk:(J ava D evelopment K it):是Java程序开发工具包，包含<strong>JRE</strong>和开发人员使用的工具。</p></blockquote><blockquote><p>JRE(J ava Runtime E nvironment):是Java程序的运行时环境，包含<strong>JVM</strong>和运行时所需要的<strong>核心类库</strong></p></blockquote><p>JDK和JRE和JVM的关系图  </p><ul><li><img src="/images/%E5%85%B3%E7%B3%BB%E5%9B%BE.PNG" alt="Alt text">  </li><li>JDK  &#x3D;  JRE  +  开发工具集  </li><li>JRE  &#x3D;  JVM  +  Java SE标准类库</li></ul><h2 id="JDK版本选择"><a href="#JDK版本选择" class="headerlink" title="JDK版本选择"></a>JDK版本选择</h2><ul><li><img src="/images/jdk%E9%80%89%E6%8B%A9.PNG" alt="Alt text"> </li><li><img src="/images/jdk%E9%80%89%E6%8B%A92.PNG" alt="Alt text"></li><li><img src="/images/jdk%E9%80%89%E6%8B%A93.PNG" alt="Alt text"></li><li><blockquote><p>自Java发布以来，其后的每次更新，都会有小伙伴高呼：你发任你发，我用Java 8</p></blockquote></li></ul><p>数据</p><ul><li><img src="/images/jdk%E9%80%89%E6%8B%A94.PNG" alt="Alt text"></li></ul><h2 id="JDK的下载"><a href="#JDK的下载" class="headerlink" title="JDK的下载"></a>JDK的下载</h2><ul><li>下载网址（Oracle公司官网）:  <a href="https://www.oracle.com/">www.oracle.com</a></li></ul><ol><li>下载步骤，如图所示,在官网底部选择Developers开发者<br><img src="/images/%E6%AD%A5%E9%AA%A41.PNG" alt="Alt text"> </li><li>在Developers页面中间的技术分类部分，选择Java，单击进入，如图所示：<br><img src="/images/%E6%AD%A5%E9%AA%A42.PNG" alt="Alt text"></li><li>在下方找到download oracle jdk 进行下载，如图所示:<br><img src="/images/%E6%AD%A5%E9%AA%A43.PNG" alt="Alt text"></li><li>点击如图所示的按钮，可选择所需要的版本进行下载，（目前推荐下载兼容的jdk8和jdk17）<br><img src="/images/%E6%AD%A5%E9%AA%A44.PNG" alt="Alt text"><br><img src="/images/%E6%AD%A5%E9%AA%A45.PNG" alt="Alt text"></li></ol><h1 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h1><ol><li><p>双击打开安装包。<br><img src="/images/%E5%AE%89%E8%A3%851.PNG" alt="Alt text"></p></li><li><p>点击下一步选择安装到文件夹中（路径最好不要有中文符号和汉字）<br><img src="/images/%E5%AE%89%E8%A3%852.PNG" alt="Alt text"></p></li><li><p>安装时如果出现安装JRE，可以选择不安装，因为jdk自带jre<br><img src="/images/%E5%AE%89%E8%A3%853.PNG" alt="Alt text"><br><img src="/images/%E5%AE%89%E8%A3%854.PNG" alt="Alt text"></p></li></ol><h1 id="配置Path环境变量"><a href="#配置Path环境变量" class="headerlink" title="配置Path环境变量"></a>配置Path环境变量</h1><ol><li><p>我的电脑右击属性<br><img src="/images/Path1.PNG" alt="Alt text"></p></li><li><p><img src="/images/Path2.PNG" alt="Alt text"></p></li><li><p><img src="/images/Path3.PNG" alt="Alt text"></p></li><li><p>在系统变量中新建一个变量名为JAVA_HOME，变量值为jdk安装的路径，如图所示<br><img src="/images/Path4.PNG" alt="Alt text"><br><img src="/images/Path5.PNG" alt="Alt text"></p></li><li><p>在找到图中的path变量双击打开或者编辑<br><img src="/images/Path6.PNG" alt="Alt text"></p></li><li><p>在新建一个，内容输入%JAVA_HOME%\bin<br><img src="/images/Path7.PNG" alt="Alt text"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编程语言来源</title>
      <link href="/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机编程语言"><a href="#计算机编程语言" class="headerlink" title="计算机编程语言"></a>计算机编程语言</h1><p><strong>计算机语言是什么</strong></p><ul><li>语言：人与人之间共同的一种方式</li><li>计算机编程语言：就是人与计算机交流的方式，人们可以使用 <strong>编程语言</strong> 对计算机下达<strong>命令</strong>，让计算机完成人们需要的功能</li><li>计算机种类： <code>C C++ Java Go JavaScript Python Scala等</code></li></ul><hr><h1 id="计算机语言简史"><a href="#计算机语言简史" class="headerlink" title="计算机语言简史"></a>计算机语言简史</h1><ul><li><p>第一代：机器语言（相当于人类的石器时代）</p><ul><li><p>1946年2月14日，世界上第一台计算机ENAC诞生，使用的是最原始的穿孔卡片，这种卡片上使用的是用二进制代码表示的语言，与人类语言差别极大，这种语言称为机器语言。</p></li><li><p><img src="/images/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80.PNG" alt="Alt text"></p></li></ul></li><li><p>第二代：汇编语言（相当于人类的青铜&amp;铁器时代）</p><ul><li><p>使用英文缩写的<strong>助记符</strong>来表示基本的操作，这些助记符构成了汇编语言的基础，比如：Load，Move等，因此，汇编语言也称为符号语言。</p></li><li><p>优点：能编写<strong>高效率</strong>的程序</p></li><li><p>缺点：汇编语言是面向机器的，不同计算机机型特点不同，因此会有不同的汇编语言，彼此之前<strong>不能通用</strong>，程序不易移植，较难调试</p></li></ul></li><li><p>第三代：高级语言（相当于人类的信息时代）</p><ul><li><p>高级语言发展于20世纪50年代中叶到70年代，是一种<strong>接近于人们使用习惯</strong>的程序设计语言，它允许程序员使用<strong>接近日常英语</strong>的指令来编写程序，程序中的符号和算式也与<strong>日常用的数学式子</strong>差不多，接近于自然语言和数学语言，容易为人们掌握。<br>  <img src="/images/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80.PNG" alt="Alt text"></p></li><li><p>高级语言<strong>独立于机器</strong>，有一定的通用性，计算机不能直接识别和执行用高级语言编写的程序，需要使用编译器或者解释器，转换为<strong>机器语言</strong>才能被识别和执行<br>  <img src="/images/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%802.PNG" alt="Alt text"><br>  <img src="/images/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%803.PNG" alt="Alt text"></p></li></ul></li><li><p>此外，高级语言按照程序设计方法的不同，可分为：<strong>面向过程的语言</strong>和<strong>面向对象的语言</strong></p><ul><li>C，Pascal,Fortran面向过程的语言</li><li>C++面向过程&#x2F;面向对象</li><li>Java跨平台的纯面向对象的语言</li><li>C#,Python,JavaScript</li></ul></li></ul><blockquote><p>目前,计算机语言仍然处于第三代高级语言阶段,但是不管是什么语言,最后都要向机器语言靠近，因为CPU只认识0和1</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件</title>
      <link href="/2023/09/05/%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/09/05/%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>什么是软件</p><blockquote><p>软件,即一系列按照特定顺序组织的计算机数据和指令的集合，有系统软件和应用软件之分</p></blockquote><p>系统软件</p><ul><li><img src="/images/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6.PNG" alt="Alt text"></li></ul><p>应用软件</p><ul><li><img src="/images/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6.PNG" alt="Alt text"></li></ul><p>人机交互方式</p><ol><li>图形化界面（GUI）</li><li>命令行方式（CLI）</li></ol><p>常见DOS命令</p><ol><li><img src="/images/DOS.PNG" alt="Alt text"></li><li><img src="/images/DOS2.PNG" alt="Alt text"></li><li><img src="/images/DOS3.PNG" alt="Alt text"></li><li><img src="/images/DOS4.PNG" alt="Alt text"></li><li><img src="/images/DOS5.PNG" alt="Alt text"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机软件与硬件</title>
      <link href="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%A1%AC%E4%BB%B6/"/>
      <url>/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%A1%AC%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机软件与硬件"><a href="#计算机软件与硬件" class="headerlink" title="计算机软件与硬件"></a>计算机软件与硬件</h3><p>计算机硬件:</p><ol><li>CPU</li></ol><ul><li>中央处理器</li></ul><ol start="2"><li>内存</li></ol><ul><li><img src="/images/%E5%86%85%E5%AD%98.PNG" alt="Alt text"></li></ul><ol start="3"><li>硬盘</li></ol><ul><li>固态硬盘(SSD)</li><li>机械硬盘(HDD)</li><li>混合硬盘(SSHD)</li></ul><ol start="4"><li>存储设备</li></ol><ul><li>磁盘</li><li>光盘</li><li>磁带</li></ul><ol start="5"><li>输入设备</li></ol><ul><li>键盘</li><li>鼠标</li></ul><ol start="6"><li>输出设备</li></ol><ul><li>显示器</li><li>打印机</li></ul><ol start="7"><li>通信设备</li></ol><ul><li>调制解调器</li><li>网卡</li></ul><p>计算机软件:</p><ol><li>系统软件</li><li>应用软件–jdk</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/01/26/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/01/26/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java反射机制研究及应用"><a href="#Java反射机制研究及应用" class="headerlink" title="Java反射机制研究及应用"></a>Java反射机制研究及应用</h3><p>Java反射机制提供的功能：</p><ul><li>在运行时判函任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h3 id="1-4反射相关的主要API"><a href="#1-4反射相关的主要API" class="headerlink" title="1.4反射相关的主要API"></a>1.4反射相关的主要API</h3><ul><li>java.lang.class：代表一个类</li><li>java.lang.reflect.Method：代表类的方法</li><li>java.lang.reflect.Field：代表类的成员变量</li><li>iava lang reflect. Constructor: 代表类的构造器</li></ul><h2 id="CLass类的理解（掌握）（如下以Java类的加载为例说明）"><a href="#CLass类的理解（掌握）（如下以Java类的加载为例说明）" class="headerlink" title="CLass类的理解（掌握）（如下以Java类的加载为例说明）"></a>CLass类的理解（掌握）（如下以Java类的加载为例说明）</h2><ul><li><p>针对于编写好门.java源文件进行编译（使用javac.ex），会生成一个或多个.class字节码文件。接着，我们使用java.exe命令对指定的.cLass文件进行解释运行。这个解释运行的过程中，我们需要将.class字节码文件加载（使用类的加载器）到内存中（存放在方法区）。加载到内存中的.class文件对应的结构即为CLass的一个实例。   </p></li><li><p>比如：加载到内存中的Person类或string类或user类，都作为Cass的一个一个的实例   </p></li><li><p>Classclazz1&#x3D;Persoh.class;&#x2F;&#x2F;运行时类</p></li><li><p>Class clazz2 : String.class;</p></li><li><p>Class clazz3 &#x3D; User,class;</p></li><li><p>Class clazz4 &#x3D; Comparable,class;</p></li><li><p>说明：运行时类在内存中会缓存起来，在整个执行期间，只会执行一次</p></li></ul><h2 id="获取CLass实例的几种方式（掌握前三种）"><a href="#获取CLass实例的几种方式（掌握前三种）" class="headerlink" title="获取CLass实例的几种方式（掌握前三种）"></a>获取CLass实例的几种方式（掌握前三种）</h2><p>调用指定的结构：指定的属性、方法、构造器  </p><h3 id="调用指定的属性（步骤）"><a href="#调用指定的属性（步骤）" class="headerlink" title="调用指定的属性（步骤）"></a>调用指定的属性（步骤）</h3><ol><li>通过cLass实例调用getDeclaredField(StringfieldName），获取运行时类指定名的属性</li><li>setAccessible(true)：确保此属性是可以访问的</li><li>通过Filed类的实例调用get（objectobj）（获取的操作）或set（objectobjObjectvalue设置的操作）进行操作。</li></ol><h3 id="调用指定的方法（步骤）"><a href="#调用指定的方法（步骤）" class="headerlink" title="调用指定的方法（步骤）"></a>调用指定的方法（步骤）</h3><ol><li>通过cLass的实例调用getDeclaredMethod(StringmethodName，CLass…args)，获取指定的方法</li><li>setAccessible（true）：确保此方法是可访问的</li><li>通过Method实例调用invoke（objectobj，Object…objs），即为对Method对应的方法的调用,<ul><li>invoke()的返回值即为Method对应的方法的返回值</li><li>特别的，如果Method对应的方法的返回值类型为void，则invoke）返回值为nuLl</li></ul></li></ol><h3 id="调用指定的构造器（步骤）"><a href="#调用指定的构造器（步骤）" class="headerlink" title="调用指定的构造器（步骤）"></a>调用指定的构造器（步骤）</h3><ol><li>通过cLass的实例调用getDeclaredConstructor（cLass…args），获取指定参数类型的构造器</li><li>setAccessible（true）：确保此构造器是可以访问的</li><li>通过constructor实例调用newInstance（object…objs），返回一个运行时类的实例。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2023/01/23/IO%E6%B5%81/"/>
      <url>/2023/01/23/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul><li>IO流的分类</li></ul><ol><li>流向的不同：输入流,输出流</li><li>处理单位的不同：字节流,字符流</li><li>流的角色的不同：节点流,处理流</li></ol><ul><li><p><img src="/images/IO%E6%B5%811.PNG" alt="Alt text"></p></li><li><p><img src="/images/IO%E6%B5%812.PNG" alt="Alt text"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2023/01/22/Map/"/>
      <url>/2023/01/22/Map/</url>
      
        <content type="html"><![CDATA[<ol><li>Map的实现类的结构：</li></ol><ul><li>—-Map:双列数据，存储key-value对的数据   —类似于高中的函数：y &#x3D; f(x)<ul><li><p>—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p><ul><li><p>—-LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。<br>  原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<br>  对于频繁的遍历操作，此类执行效率高于HashMap。</p></li><li><p>—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序<br>       底层使用红黑树</p></li><li><p>—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p><ul><li>—-Properties:常用来处理配置文件。key和value都是String类型</li></ul></li></ul></li><li><p>HashMap的底层：数组+链表  （jdk7及之前）</p></li><li><p>数组+链表+红黑树 （jdk 8）</p></li></ul></li></ul><p> 面试题：</p><ol><li>HashMap的底层实现原理？</li><li>HashMap 和 Hashtable的异同？</li><li>CurrentHashMap 与 Hashtable的异同？（暂时不讲）</li></ol><p> 二、Map结构的理解：<br>   Map中的key:无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</p><p>   Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()</p><p>   一个键值对：key-value构成了一个Entry对象。</p><p>   Map中的entry:无序的、不可重复的，使用Set存储所有的entry</p><p> 三、HashMap的底层实现原理？以jdk7为例说明：</p><pre><code> HashMap map = new HashMap(): 在实例化以后，底层创建了长度是16的一维数组Entry[] table。 ...可能已经执行过多次put... map.put(key1,value1): 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 的哈希值：         如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2         如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：                 如果equals()返回false:此时key1-value1添加成功。----情况3                 如果equals()返回true:使用value1替换value2。  补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 jdk8 相较于jdk7在底层实现方面的不同： 1.. new HashMap():底层没有创建一个长度为16的数组  2. jdk 8底层的数组是：Node[],而非Entry[] 3. 首次调用put()方法时，底层创建长度为16的数组  4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。     4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）    4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</code></pre><ol start="4"><li>LinkedHashMap的底层实现原理（了解）<br>  源码中：    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">      Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line">      Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2023/01/22/List/"/>
      <url>/2023/01/22/List/</url>
      
        <content type="html"><![CDATA[<h3 id="List接口框架"><a href="#List接口框架" class="headerlink" title="List接口框架"></a>List接口框架</h3><ul><li>—-Collection接口：单列集合，用来存储一个一个的对象<br>* —-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<ul><li>—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li><li>—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li>—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li></ul></li></ul><ol start="2"><li>ArrayList的源码分析：</li></ol><ul><li><p>jdk 7情况下<br>   ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData  </p><p>   list.add(123);&#x2F;&#x2F;elementData[0] &#x3D; new    Integer(123);<br>   …<br>   list.add(11);&#x2F;&#x2F;如果此次的添加导致底层elementData数组容量不够，则扩容。</p><p>   默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p><p>   结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</p></li><li><p>jdk 8中ArrayList的变化：<br>   ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p><p>   list.add(123);&#x2F;&#x2F;第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到</p><p>   elementData[0]<br>   …<br>   后续的添加和扩容操作与jdk 7 无异。</p></li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li><p>jdk7中的ArrayList的对象的创建类似于单例的饿汉式，</p></li><li><p>jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p></li></ul><ol start="3"><li>LinkedList的源码分析：</li></ol><ul><li><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p></li><li><p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。</p></li><li><p>其中，Node定义为：体现了LinkedList的双向链表的说法<br>   private static class Node<E> {<br>    E item;<br>    Node<E> next;<br>    Node<E> prev;<br>    Node(Node<E> prev, E element, Node<E> next) {<br>    this.item &#x3D; element;<br>    this.next &#x3D; next;<br>    this.prev &#x3D; prev;<br>    }<br>}</p></li></ul><ol start="4"><li><p>Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><ul><li>在扩容方面，默认扩容为原来的数组长度的2倍。</li></ul></li></ol><p> 面试题：ArrayList、LinkedList、Vector三者的异同？<br> 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据<br> 不同：见上</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2022/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h3><table><thead><tr><th align="left">班级</th><th align="right">姓名</th><th align="center">性别</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="left">1班</td><td align="right">张三</td><td align="center">男</td><td align="center">99</td></tr><tr><td align="left">2班</td><td align="right">李四</td><td align="center">女</td><td align="center">100</td></tr><tr><td align="left">3班</td><td align="right">王二</td><td align="center">男</td><td align="center">98</td></tr></tbody></table><blockquote><p>李四成绩大于张三，所以李四的成绩最好</p></blockquote><p>李四学习计划:</p><ol><li>早起</li><li>自律</li><li>早睡</li></ol><p>张三学习计划：</p><ul><li>早起</li><li>自律</li><li>晚睡</li></ul><p>明天要做的事:</p><ul><li>[ ]吃饭</li><li>[x]打豆豆</li><li>[ ]睡觉</li></ul><p>代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/09/hello-world/"/>
      <url>/2022/11/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="/title/index.html"/>
      <url>/title/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
